#!/usr/bin/perl -w

# Tool to generate source code for stub libraries
#
# (C) Copyright 2001 The Free Standards Group  Inc
#
# Chris Yeoh (cyeoh@samba.org), IBM
#
# This is $Revision: 1.2 $
#
# $Log: mkstublibs,v $
# Revision 1.2  2001/09/04 02:27:42  cyeoh
# Load data file containing symbol/size pairs. This is a workaround
# for missing data in the LSB database. It is also IA32 specific.
#
# Revision 1.1  2001/08/27 08:01:08  cyeoh
# Adds core files needed for lsb stub library generation
#
#

use strict;
use DBI;
use Getopt::Std;

my($DBName) = "lsb";
my($DBUser) = "";
my($DBPass)  = "";
my($DBHost) = "";
my($TargetArch);
my($TargetArchId);
my(%Options);
my(%MissingData);

# Load data missing from database for size of variables
# IA32 specific!
sub LoadMissingData()
{
  local(*DATAFILE);
  my($line);
  my($symbol, $size);
  if (open(DATAFILE, "missing_data.txt"))
  {
    while (defined($line = <DATAFILE>))
    {
      if ($line =~ /^\#/)
      {
        # Comment
        next;
      }
      else
      {
        chomp($line);
        ($symbol, $size) = split(/\s+/, $line);
        if (defined($MissingData{$symbol}))
        {
          print "Warning: $symbol defined twice in missing_data.txt\n";
        }
        $MissingData{$symbol} = hex($size);
      }
    }
    close(DATAFILE);
  }
  else
  {
    print "Could not open missing_data.txt\n";
  }
}

######################################################################
# Generate C stub code for a library
sub GenerateLibrary($$$)
{
  my($dbh) = shift;
  my($libName) = shift;
  my($libId) = shift;
  my($sth);
  my($row);
  my(%versionInfo);
  local(*STUBFILE);
  local(*VERSIONFILE);

  open(STUBFILE, ">$libName.c") || die "Could not open $libName.c to write\n";
  open(VERSIONFILE, ">$libName.Version") 
      || die "Could not open $libName.c to write\n";
  
  # Do functions first
  $sth = $dbh->prepare("SELECT DISTINCT Iname,Vname FROM Interface,LibGroup, ".
                       "LGInt LEFT JOIN Version ON Vid=Iversion ".
                       "WHERE Itype='Function' AND ".
                       "Interface.Iid=LGInt.LGIint AND Istatus='Included'".
                       "AND LGInt.LGIlibg=LibGroup.LGid ".
                       "AND LibGroup.LGlib=$libId ORDER BY Iname")
      || die $dbh->errstr;  
  $sth->execute() || die $sth->errstr;
  while ($row = $sth->fetchrow_hashref())
  {
    print(STUBFILE "void $row->{Iname}(void) {} ;\n");
    if (defined($row->{Vname}))
    {
      # Unversioned symbols will not have the Vname field defined
      if (!defined($versionInfo{$row->{Vname}}))
      {
        $versionInfo{$row->{Vname}} = ();
      }
      push(@{$versionInfo{$row->{Vname}}}, $row->{Iname});
    }
  }

  # Do variables next
  $sth = $dbh->prepare("SELECT DISTINCT Iname,Vname,Ireturn,ATsize FROM ".
                       "Interface,LibGroup,LGInt ".
                       "LEFT JOIN Version ON Vid=Iversion ".
                       "LEFT JOIN ArchType ON ATtid=Ireturn and ".
                       "ATaid=$TargetArchId WHERE ".
                       "Itype='Data' AND Interface.Iid=LGInt.LGIint ".
                       "AND Istatus='Included' ".
                       "AND LGInt.LGIlibg=LibGroup.LGid ".
                       "AND LibGroup.LGlib=$libId ORDER BY Iname")
      || die $dbh->errstr;  
  $sth->execute() || die $sth->errstr;
  my($size);
  while ($row = $sth->fetchrow_hashref())
  {
    # Work out size of data variable
    if (!defined($row->{"ATsize"}) || $row->{"ATsize"} == 0)
    {
      if (defined($MissingData{$row->{Iname}}))
      {
        $size = $MissingData{$row->{Iname}};
      }
      else
      {
        die "No data for symbol $row->{Iname}\n";
      }
#      print STDOUT "Size not available for symbol $row->{Iname}"
#          . "  Type ($row->{Ireturn})\n";
#      $size = 1000; # temporarily make it big to avoid problems
    }
#      elsif ($row->{"ATsize"} == 0)
#      {
#        print STDOUT "Size for symbol $row->{Iname} of Type $row->{Ireturn} is 0\n";
#        $size = 1000; # temporarily make it big to avoid problems
#      }
    else
    {
      $size = $row->{"ATsize"};
    }
    print(STUBFILE "__asm__(\".comm $row->{Iname},$size\");\n");
    die "Size 0 symbol for $row->{Iname}\n" unless $size!=0;

    if (defined($row->{Vname}))
    {
      # Unversioned symbols will not have the Vname field defined
      if (!defined($versionInfo{$row->{Vname}}))
      {
        $versionInfo{$row->{Vname}} = ();
      }
      push(@{$versionInfo{$row->{Vname}}}, $row->{Iname});
    }
  }

  # Dump version information
  my($version);
  my($symbol);
  my($symbols);
  print VERSIONFILE "LSB_DUMMY { __LSB_DUMMY; };\n";
  foreach $version (sort keys %versionInfo)
  {
    $symbols = $versionInfo{$version};
    print VERSIONFILE "$version {\n";

    foreach $symbol (@$symbols)
    {
      print VERSIONFILE "  $symbol;\n";
    }
    print VERSIONFILE "};\n";
  }

  close(STUBFILE);
  close(VERSIONFILE);
}


######################################################################
# Main bit
getopts('d:u:p:o:ha:', \%Options);

if (exists($Options{'h'}))
{
  print STDERR <<"EOM"
Usage $0 -a arch [-d db_name] [-u username] [-p password] [-o hostname] [-h]
    -h           Display this help
    -d db_name   Database name
    -u username  Name of user for db access
    -p password  Password for db access
    -o hostname  Hostname for DB
    -a arch      Architecture to generate shared libraries for
                 (Note this is not magic - you have to compile it on
                  the correct platform still!)
EOM
    ;
  exit(1);
}

if (defined($Options{'a'}))
{
  $TargetArch = $Options{'a'};
}
else
{
  die "Must define target architecture\n";
}

$DBUser = $Options{'u'} if exists($Options{'u'});
$DBPass = $Options{'p'} if exists($Options{'p'});
$DBHost = $Options{'o'} if exists($Options{'o'});
$DBName = $Options{'d'} if exists($Options{'d'});

my($dbh);
my($sth);
my($row);
my($data_source) = "DBI:mysql:database=$DBName";
if ($DBHost ne "")
{
  $data_source .= ";host=$DBHost";
}

$dbh = DBI->connect($data_source, $DBUser, $DBPass)
    || die "Could not connect to database\n";


# Get architecture information
$sth = $dbh->prepare("SELECT Aid from Architecture where Aname='$TargetArch'")
    || die $dbh->errstr;
$sth->execute() || die $sth->errstr;
$row = $sth->fetchrow_hashref;
if (!defined($row))
{
  die "Unknown Architecture $TargetArch\n";
}
else
{
  $TargetArchId = $row->{Aid};
}

LoadMissingData();

# Map of name to run-time name of shared library
local(*LIBMAPFILE);
open(LIBMAPFILE, ">LibNameMap.txt") 
    || die "Could not open file LibNameMap.txt file for writing\n";

# Get list of libraries we want to produce stub libraries for
$sth = $dbh->prepare("SELECT Lid,Lname,Lrunname FROM Library "
                     . "where Library.Lstd='Yes'")
    || die $dbh->errstr;
$sth->execute() || die $sth->errstr;

while ($row = $sth->fetchrow_hashref)
{
  print "Generating c stubs for $row->{Lname} library\n";
  print LIBMAPFILE "$row->{Lname} $row->{Lrunname}\n";
  GenerateLibrary($dbh, $row->{Lname}, $row->{Lid});
}


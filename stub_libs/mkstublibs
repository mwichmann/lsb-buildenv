#!/usr/bin/perl -w

# Tool to generate source code for stub libraries
#
# (C) Copyright 2001 The Free Standards Group  Inc
#
# Chris Yeoh (cyeoh@samba.org), IBM
#
# This is $Revision: 1.5 $
#
# $Log: mkstublibs,v $
# Revision 1.5  2001/10/24 05:19:56  cyeoh
# Add workaround for missing symbols
#
# Revision 1.4  2001/10/22 07:28:47  cyeoh
# Add temporary work around for symbols either misclassified or missing
# from the LSB db
#
# Revision 1.3  2001/10/19 07:19:45  cyeoh
# Applies workaround for variables which are in reality just aliases to
# other variables but this information is not stored in the database
# so we use a hardcoded lookup table.
#
# Revision 1.2  2001/09/04 02:27:42  cyeoh
# Load data file containing symbol/size pairs. This is a workaround
# for missing data in the LSB database. It is also IA32 specific.
#
# Revision 1.1  2001/08/27 08:01:08  cyeoh
# Adds core files needed for lsb stub library generation
#
#

use strict;
use DBI;
use Getopt::Std;

my($DBName) = "lsb";
my($DBUser) = "";
my($DBPass)  = "";
my($DBHost) = "";
my($TargetArch);
my($TargetArchId);
my(%Options);
my(%MissingData);
my(%LibcAliases) = (
  "sys_errlist" => "_sys_errlist",
  "tzname" => "__tzname",
  "daylight" => "__daylight",
  "timezone" => "__timezone",
  "_environ" => "__environ",
  "environ" => "__environ",
  "___brk_addr" => "__curbrk",
  "program_invocation_name" => "__progname_full",
  "program_invocation_short_name" => "__progname",
  "_h_errno" => "h_errno" );

# The following need to sit in the data segment instead of the bss
my(%LibcData) = ( 
  "_sys_errlist" => 1,
  "__tzname" => 1,
  "__daylight" => 1,
  "__timezone" => 1,
  "__environ" => 1,
  "__curbrk" => 1,
  "__progname_full" => 1,
  "__progname" => 1,
  "h_errno" => 1 );


# Work around bugs in database
# Interfaces which should be a variable but are recorded as a function
# (or just missing)
# Zero size means alias 
my(%OverrideVariables) = 
    (
     "libc" => { "_h_errno" => 0x4,
                 "daylight" => 0,
                 "tzname" => 0,
                 "__tzname" => 0x8,
                 "__daylight" => 0x4,
                 "__timezone" => 0x4},
     "libXt" => { "XtShellStrings" => 0x509,
                  "XtStrings" => 0xa59 }
     );

# Work around bugs in database
# Interfaces which should be functions but are recorded as a variable
my(%OverrideFunctions) = 
    (
     "libm" => { "clog" => 1 } 
     );

# Work around bugs in database
# Missing libc symbols
my(%MissingLibcVariables) =
    ( "__tzname" => "GLIBC_2.0",
      "__daylight" => "GLIBC_2.0",
      "__timezone" => "GLIBC_2.0" );


#----------------------------------------------------------------------
# Look through local shared libraries for aliases
# We only do this because the database does not (yet) have this
# information.
sub GenerateAliases($)
{
  my($libfilename) = shift;
  my($aliases) = {};
  my(@searchDirs) = ("/", "/lib", "/usr/lib", "/usr/X11R6/lib");
  my($loop);
  my($useDir);
  my(%lookup);
  my(@nmLine);
  
  local(*NMOUTPUT);

  foreach $loop (@searchDirs)
  {
    if (-f "$loop/$libfilename")
    {
      $useDir = $loop;
      last;
    }
  }
  if (!defined($useDir))
  {
    die "Could not find $libfilename in search path (for aliases): @searchDirs\n";
  }
  
  if (system("nm -D $useDir/$libfilename | sort > /tmp/mkstublibs.$$")
      /256!=0)
  {
    die "nm of shared library failed\n";
  }
  
  my($line);
  if (open(NMOUTPUT, "/tmp/mkstublibs.$$"))
  {
    while (defined($line = <NMOUTPUT>))
    {
      chomp($line);
      @nmLine = split(/ /, $line);
      if ($#nmLine==2)
      {
        if ($nmLine[1] eq "D")
        {
          $lookup{$nmLine[0]} = $nmLine[2];
        }
      }
    }
    seek(NMOUTPUT, 0, 0);
    while (defined($line = <NMOUTPUT>))
    {
      chomp($line);
      @nmLine = split(/ /, $line);
      if ($#nmLine==2)
      {
        if ($nmLine[1] eq "V")
        {
          if (exists($lookup{$nmLine[0]}))
          {
            print "Found alias: $nmLine[2] is alias to $lookup{$nmLine[0]}\n";
            $aliases->{$nmLine[2]} = $lookup{$nmLine[0]};
          }
        }
      }
    }
  }
  else
  {
    die "Failed to open temorary file: /tmp/mkstublibs.$$\n";
  }

}


#----------------------------------------------------------------------
# Load data missing from database for size of variables
# IA32 specific!
sub LoadMissingData()
{
  local(*DATAFILE);
  my($line);
  my($symbol, $size);
  if (open(DATAFILE, "missing_data.txt"))
  {
    while (defined($line = <DATAFILE>))
    {
      if ($line =~ /^\#/)
      {
        # Comment
        next;
      }
      else
      {
        chomp($line);
        ($symbol, $size) = split(/\s+/, $line);
        if (defined($MissingData{$symbol}))
        {
          print "Warning: $symbol defined twice in missing_data.txt\n";
        }
        $MissingData{$symbol} = hex($size);
      }
    }
    close(DATAFILE);
  }
  else
  {
    print "Could not open missing_data.txt\n";
  }
}

######################################################################
# Generate C stub code for a library
sub GenerateLibrary($$$)
{
  my($dbh) = shift;
  my($libName) = shift;
  my($libId) = shift;
  my($sth);
  my($row);
  my(%versionInfo);
  local(*STUBFILE);
  local(*VERSIONFILE);

  open(STUBFILE, ">$libName.c") || die "Could not open $libName.c to write\n";
  open(VERSIONFILE, ">$libName.Version") 
      || die "Could not open $libName.c to write\n";
  
  # Do functions first
  $sth = $dbh->prepare("SELECT DISTINCT Iname,Vname FROM Interface,LibGroup, ".
                       "LGInt LEFT JOIN Version ON Vid=Iversion ".
                       "WHERE Itype='Function' AND ".
                       "Interface.Iid=LGInt.LGIint AND Istatus='Included'".
                       "AND LGInt.LGIlibg=LibGroup.LGid ".
                       "AND LibGroup.LGlib=$libId ORDER BY Iname")
      || die $dbh->errstr;  
  $sth->execute() || die $sth->errstr;
  while ($row = $sth->fetchrow_hashref())
  {
    if (exists($OverrideVariables{$libName})
        && exists($OverrideVariables{$libName}{$row->{Iname}}))
    {
      # Skipped because its misclassified in the db
      # (Still do following versioning information because this is correct
      # and is written to the same file)
#      print "Skipping $row->{Iname}\n";
    }
    else
    {
      print(STUBFILE "void $row->{Iname}(void) {} ;\n");
    }
    if (defined($row->{Vname}))
    {
      # Unversioned symbols will not have the Vname field defined
      if (!defined($versionInfo{$row->{Vname}}))
      {
        $versionInfo{$row->{Vname}} = ();
      }
      push(@{$versionInfo{$row->{Vname}}}, $row->{Iname});
    }
  }

  if (exists($OverrideFunctions{$libName}))
  {
    # Add misclassified interfaces
    my($missing);
    foreach $missing (keys %{$OverrideFunctions{$libName}})
    {
#    print "Fixing $missing\n";
      print(STUBFILE "void $missing(void) {} ;\n");
    }
  }

  # Do variables next
  $sth = $dbh->prepare("SELECT DISTINCT Iname,Vname,Ireturn,ATsize FROM ".
                       "Interface,LibGroup,LGInt ".
                       "LEFT JOIN Version ON Vid=Iversion ".
                       "LEFT JOIN ArchType ON ATtid=Ireturn and ".
                       "ATaid=$TargetArchId WHERE ".
                       "Itype='Data' AND Interface.Iid=LGInt.LGIint ".
                       "AND Istatus='Included' ".
                       "AND LGInt.LGIlibg=LibGroup.LGid ".
                       "AND LibGroup.LGlib=$libId ORDER BY Iname")
      || die $dbh->errstr;  
  $sth->execute() || die $sth->errstr;
  my($size);
  while ($row = $sth->fetchrow_hashref())
  {
    if (defined($OverrideFunctions{$libName})
        && exists($OverrideFunctions{$libName}{$row->{Iname}}))
    {
      # Skipped because its misclassified in the db
    }
    else
    {
      # Work out size of data variable
      if (!defined($row->{"ATsize"}) || $row->{"ATsize"} == 0)
      {
        if (defined($MissingData{$row->{Iname}}))
        {
          $size = $MissingData{$row->{Iname}};
        }
        else
        {
          die "No data for symbol $row->{Iname}\n";
        }
#      print STDOUT "Size not available for symbol $row->{Iname}"
#          . "  Type ($row->{Ireturn})\n";
#      $size = 1000; # temporarily make it big to avoid problems
      }
#      elsif ($row->{"ATsize"} == 0)
#      {
#        print STDOUT "Size for symbol $row->{Iname} of Type $row->{Ireturn} is 0\n";
#        $size = 1000; # temporarily make it big to avoid problems
#      }
      else
      {
        $size = $row->{"ATsize"};
      }
      
      if ($libName ne "libc" || (!exists($LibcAliases{$row->{Iname}})
                                 && !exists($LibcData{$row->{Iname}})) )
      {
        print(STUBFILE "__asm__(\".comm $row->{Iname},$size\");\n");
      }
      elsif (exists($LibcAliases{$row->{Iname}}))
      {
        print(STUBFILE "__asm__(\".weak $row->{Iname}; $row->{Iname} = $LibcAliases{$row->{Iname}}\");\n");
      }
      else
      {
        my($varname) = $row->{Iname};
        print(STUBFILE "__asm__(\".globl $varname; .data; .type $varname,\@object; .size $varname, $size; $varname: .long 0\");\n");
      }



      die "Size 0 symbol for $row->{Iname}\n" unless $size!=0;
    }

    if (defined($row->{Vname}))
    {
      # Unversioned symbols will not have the Vname field defined
      if (!defined($versionInfo{$row->{Vname}}))
      {
        $versionInfo{$row->{Vname}} = ();
      }
      push(@{$versionInfo{$row->{Vname}}}, $row->{Iname});
    }

    # Work around for missing __tzname symbol
    if ($libName eq "libc" && $row->{Iname} eq "__tzname")
    {
      push(@{$versionInfo{"GLIBC_2.0"}}, "__tzname");
    }


  }

  if (exists($OverrideVariables{$libName}))
  {
#    print "Found for $libName\n";
    # Add misclassified or missing interfaces
    my($missing);
    foreach $missing (keys %{$OverrideVariables{$libName}})
    {
#      print "Fixing $missing\n";
      if ($libName eq "libc")
      {
        if (exists($LibcAliases{$missing}))
        {
          print(STUBFILE "__asm__(\".weak $missing; $missing = $LibcAliases{$missing}\");\n");
        }
        else
        {
          print(STUBFILE "__asm__(\".globl $missing; .data; .type $missing,\@object; .size $missing, $size; $missing: .long 0\");\n");
        }
      }
      else
      {
        print(STUBFILE "__asm__(\".comm $missing,$OverrideVariables{$libName}{$missing}\");\n");
      }
    }
  }


  # Dump version information
  my($version);
  my($symbol);
  my($symbols);
  print VERSIONFILE "LSB_DUMMY { __LSB_DUMMY; };\n";
  foreach $version (sort keys %versionInfo)
  {
    $symbols = $versionInfo{$version};
    print VERSIONFILE "$version {\n";

    foreach $symbol (@$symbols)
    {
      print VERSIONFILE "  $symbol;\n";
    }
    print VERSIONFILE "};\n";
  }

  close(STUBFILE);
  close(VERSIONFILE);
}


######################################################################
# Main bit
getopts('d:u:p:o:ha:', \%Options);

if (exists($Options{'h'}))
{
  print STDERR <<"EOM"
Usage $0 -a arch [-d db_name] [-u username] [-p password] [-o hostname] [-h]
    -h           Display this help
    -d db_name   Database name
    -u username  Name of user for db access
    -p password  Password for db access
    -o hostname  Hostname for DB
    -a arch      Architecture to generate shared libraries for
                 (Note this is not magic - you have to compile it on
                  the correct platform still!)
EOM
    ;
  exit(1);
}

if (defined($Options{'a'}))
{
  $TargetArch = $Options{'a'};
}
else
{
  die "Must define target architecture\n";
}

$DBUser = $Options{'u'} if exists($Options{'u'});
$DBPass = $Options{'p'} if exists($Options{'p'});
$DBHost = $Options{'o'} if exists($Options{'o'});
$DBName = $Options{'d'} if exists($Options{'d'});

my($dbh);
my($sth);
my($row);
my($data_source) = "DBI:mysql:database=$DBName";
if ($DBHost ne "")
{
  $data_source .= ";host=$DBHost";
}

$dbh = DBI->connect($data_source, $DBUser, $DBPass)
    || die "Could not connect to database\n";


# Get architecture information
$sth = $dbh->prepare("SELECT Aid from Architecture where Aname='$TargetArch'")
    || die $dbh->errstr;
$sth->execute() || die $sth->errstr;
$row = $sth->fetchrow_hashref;
if (!defined($row))
{
  die "Unknown Architecture $TargetArch\n";
}
else
{
  $TargetArchId = $row->{Aid};
}

LoadMissingData();

# Map of name to run-time name of shared library
local(*LIBMAPFILE);
open(LIBMAPFILE, ">LibNameMap.txt") 
    || die "Could not open file LibNameMap.txt file for writing\n";

# Get list of libraries we want to produce stub libraries for
$sth = $dbh->prepare("SELECT Lid,Lname,Lrunname FROM Library "
                     . "where Library.Lstd='Yes'")
    || die $dbh->errstr;
$sth->execute() || die $sth->errstr;

my($dataAliases);
while ($row = $sth->fetchrow_hashref)
{
  print "Generating c stubs for $row->{Lname} library ($row->{Lrunname})\n";
  print LIBMAPFILE "$row->{Lname} $row->{Lrunname}\n";
#  $dataAliases = GenerateAliases($row->{Lrunname});
  GenerateLibrary($dbh, $row->{Lname}, $row->{Lid});
}


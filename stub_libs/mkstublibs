#!/usr/bin/perl -w

# Tool to generate source code for stub libraries
#
# (C) Copyright 2001 The Free Standards Group  Inc
#
# Chris Yeoh (cyeoh@samba.org), IBM
#
# This is $Revision: 1.7 $
#
# $Log: mkstublibs,v $
# Revision 1.7  2001/12/18 01:04:58  cyeoh
# Remove warning message
#
# Revision 1.6  2001/11/20 04:03:57  anderson
# Change to pick up the DB access into from the environment as is done for
# all of the other scripts
# Eliminate most of the workaround required becasue of bad data.
# Eliminate several of the proceedural heuristics required to work around
# bad data.
# The Aliases are still needed until that info can be reflected in the DB.
# Another pass will be required to finish eliminating workarounds.
#
# Revision 1.5  2001/10/24 05:19:56  cyeoh
# Add workaround for missing symbols
#
# Revision 1.4  2001/10/22 07:28:47  cyeoh
# Add temporary work around for symbols either misclassified or missing
# from the LSB db
#
# Revision 1.3  2001/10/19 07:19:45  cyeoh
# Applies workaround for variables which are in reality just aliases to
# other variables but this information is not stored in the database
# so we use a hardcoded lookup table.
#
# Revision 1.2  2001/09/04 02:27:42  cyeoh
# Load data file containing symbol/size pairs. This is a workaround
# for missing data in the LSB database. It is also IA32 specific.
#
# Revision 1.1  2001/08/27 08:01:08  cyeoh
# Adds core files needed for lsb stub library generation
#
#

use strict;
use DBI;
use Getopt::Std;

use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);

my($DBName) = $LSBDB;
my($DBUser) = $LSBUSER;
my($DBPass)  = $LSBDBPASSWD;
my($DBHost) = $LSBDBHOST;
my($TargetArch);
my($TargetArchId);
my(%Options);
my(%MissingData);
my(%LibcAliases) = (
  "sys_errlist" => "_sys_errlist",
  "tzname" => "__tzname",
  "daylight" => "__daylight",
  "timezone" => "__timezone",
  "_environ" => "__environ",
  "environ" => "__environ",
  "___brk_addr" => "__curbrk",
  "program_invocation_name" => "__progname_full",
  "program_invocation_short_name" => "__progname",
  "_h_errno" => "h_errno" );

#----------------------------------------------------------------------
# Look through local shared libraries for aliases
# We only do this because the database does not (yet) have this
# information.
sub GenerateAliases($)
{
  my($libfilename) = shift;
  my($aliases) = {};
  my(@searchDirs) = ("/", "/lib", "/usr/lib", "/usr/X11R6/lib");
  my($loop);
  my($useDir);
  my(%lookup);
  my(@nmLine);
  
  local(*NMOUTPUT);

  foreach $loop (@searchDirs)
  {
    if (-f "$loop/$libfilename")
    {
      $useDir = $loop;
      last;
    }
  }
  if (!defined($useDir))
  {
    die "Could not find $libfilename in search path (for aliases): @searchDirs\n";
  }
  
  if (system("nm -D $useDir/$libfilename | sort > /tmp/mkstublibs.$$")
      /256!=0)
  {
    die "nm of shared library failed\n";
  }
  
  my($line);
  if (open(NMOUTPUT, "/tmp/mkstublibs.$$"))
  {
    while (defined($line = <NMOUTPUT>))
    {
      chomp($line);
      @nmLine = split(/ /, $line);
      if ($#nmLine==2)
      {
        if ($nmLine[1] eq "D")
        {
          $lookup{$nmLine[0]} = $nmLine[2];
        }
      }
    }
    seek(NMOUTPUT, 0, 0);
    while (defined($line = <NMOUTPUT>))
    {
      chomp($line);
      @nmLine = split(/ /, $line);
      if ($#nmLine==2)
      {
        if ($nmLine[1] eq "V")
        {
          if (exists($lookup{$nmLine[0]}))
          {
            print "Found alias: $nmLine[2] is alias to $lookup{$nmLine[0]}\n";
            $aliases->{$nmLine[2]} = $lookup{$nmLine[0]};
          }
        }
      }
    }
  }
  else
  {
    die "Failed to open temorary file: /tmp/mkstublibs.$$\n";
  }

}


#----------------------------------------------------------------------
# Load data missing from database for size of variables
# IA32 specific!
sub LoadMissingData()
{
  local(*DATAFILE);
  my($line);
  my($symbol, $size);
  if (open(DATAFILE, "missing_data.txt"))
  {
    while (defined($line = <DATAFILE>))
    {
      if ($line =~ /^\#/)
      {
        # Comment
        next;
      }
      else
      {
        chomp($line);
        ($symbol, $size) = split(/\s+/, $line);
        if (defined($MissingData{$symbol}))
        {
          print "Warning: $symbol defined twice in missing_data.txt\n";
        }
        $MissingData{$symbol} = hex($size);
      }
    }
    close(DATAFILE);
  }
  else
  {
    print "Could not open missing_data.txt\n";
  }
}

######################################################################
# Generate C stub code for a library
sub GenerateLibrary($$$)
{
  my($dbh) = shift;
  my($libName) = shift;
  my($libId) = shift;
  my($sth);
  my($select);
  my($row);
  my(%versionInfo);
  local(*STUBFILE);
  local(*VERSIONFILE);

  open(STUBFILE, ">$libName.c") || die "Could not open $libName.c to write\n";
  open(VERSIONFILE, ">$libName.Version") 
      || die "Could not open $libName.c to write\n";
  
  # Do functions first
  $sth = $dbh->prepare("SELECT DISTINCT Iname,Vname FROM Interface,LibGroup, ".
                       "LGInt LEFT JOIN Version ON Vid=Iversion ".
                       "WHERE Itype='Function' AND ".
                       "Interface.Iid=LGInt.LGIint AND Istatus='Included'".
                       "AND LGInt.LGIlibg=LibGroup.LGid ".
                       "AND LibGroup.LGlib=$libId ORDER BY Iname")
      || die $dbh->errstr;  
  $sth->execute() || die $sth->errstr;
  while ($row = $sth->fetchrow_hashref())
  {
    print(STUBFILE "void $row->{Iname}(void) {} ;\n");
    if (defined($row->{Vname}))
    {
      # Unversioned symbols will not have the Vname field defined
      if (!defined($versionInfo{$row->{Vname}}))
      {
        $versionInfo{$row->{Vname}} = ();
      }
      push(@{$versionInfo{$row->{Vname}}}, $row->{Iname});
    }
  }

  # Do variables next
  $select = "SELECT DISTINCT Iname,Itype,Vname,Ireturn,ATsize FROM ".
                       "Interface,LibGroup,LGInt ".
                       "LEFT JOIN Version ON Vid=Iversion ".
                       "LEFT JOIN ArchType ON ATtid=Ireturn and ".
                       "ATaid=$TargetArchId WHERE ".
                       "( Itype='Data' OR Itype='Alias' OR Itype='Common' ) ".
                       "AND Interface.Iid=LGInt.LGIint ".
                       "AND Istatus='Included' ".
                       "AND LGInt.LGIlibg=LibGroup.LGid ".
                       "AND LibGroup.LGlib=$libId ORDER BY Iname";
  #print "$select\n";
  $sth = $dbh->prepare($select) || die $dbh->errstr;  
  $sth->execute() || die $sth->errstr;
  my($size);
  while ($row = $sth->fetchrow_hashref())
  {
      # Work out size of data variable
      if (!defined($row->{"ATsize"}) || $row->{"ATsize"} == 0)
      {
        if (defined($MissingData{$row->{Iname}}))
        {
          $size = $MissingData{$row->{Iname}};
        }
        else
        {
          print "No data for symbol $row->{Iname}\n";
        }
      print STDOUT "Size not available for symbol $row->{Iname}"
          . "  Type ($row->{Ireturn})\n";
#      $size = 1000; # temporarily make it big to avoid problems
      }
      elsif ($row->{"ATsize"} == 0)
      {
        print STDOUT "Size for symbol $row->{Iname} of Type $row->{Ireturn} is 0\n";
#        $size = 1000; # temporarily make it big to avoid problems
      }
      else
      {
        $size = $row->{"ATsize"};
      }
      
      if($row->{Itype} eq "Common" )
      {
        print(STUBFILE "__asm__(\".comm $row->{Iname},$size\");\n");
      }
      elsif($row->{Itype} eq "Alias" )
      {
        print(STUBFILE "__asm__(\".weak $row->{Iname}; $row->{Iname} = $LibcAliases{$row->{Iname}}\");\n");
      }
      elsif($row->{Itype} eq "Data" )
      {
        my($varname) = $row->{Iname};
        print(STUBFILE "__asm__(\".globl $varname; .data; .type $varname,\@object; .size $varname, $size; $varname: .long 0\");\n");
      }
      else
      {
        print "Skipping ",$row->{Iname},"\n";
      }

    if (defined($row->{Vname}))
    {
      # Unversioned symbols will not have the Vname field defined
      if (!defined($versionInfo{$row->{Vname}}))
      {
        $versionInfo{$row->{Vname}} = ();
      }
      push(@{$versionInfo{$row->{Vname}}}, $row->{Iname});
    }

  }

  # Dump version information
  my($version);
  my($symbol);
  my($symbols);
  print VERSIONFILE "LSB_DUMMY { __LSB_DUMMY; };\n";
  foreach $version (sort keys %versionInfo)
  {
    $symbols = $versionInfo{$version};
    print VERSIONFILE "$version {\n";

    foreach $symbol (@$symbols)
    {
      print VERSIONFILE "  $symbol;\n";
    }
    print VERSIONFILE "};\n";
  }

  close(STUBFILE);
  close(VERSIONFILE);
}


######################################################################
# Main bit
getopts('d:u:p:o:ha:', \%Options);

if (exists($Options{'h'}))
{
  print STDERR <<"EOM"
Usage $0 -a arch [-d db_name] [-u username] [-p password] [-o hostname] [-h]
    -h           Display this help
    -d db_name   Database name
    -u username  Name of user for db access
    -p password  Password for db access
    -o hostname  Hostname for DB
    -a arch      Architecture to generate shared libraries for
                 (Note this is not magic - you have to compile it on
                  the correct platform still!)
EOM
    ;
  exit(1);
}

if (defined($Options{'a'}))
{
  $TargetArch = $Options{'a'};
}
else
{
  die "Must define target architecture\n";
}

$DBUser = $Options{'u'} if exists($Options{'u'});
$DBPass = $Options{'p'} if exists($Options{'p'});
$DBHost = $Options{'o'} if exists($Options{'o'});
$DBName = $Options{'d'} if exists($Options{'d'});

my($dbh);
my($sth);
my($row);
my($data_source) = "DBI:mysql:database=$DBName";
if (defined($DBHost) && $DBHost ne "")
{
  $data_source .= ";host=$DBHost";
}

$dbh = DBI->connect($data_source, $DBUser, $DBPass)
    || die "Could not connect to database\n";


# Get architecture information
$sth = $dbh->prepare("SELECT Aid from Architecture where Aname='$TargetArch'")
    || die $dbh->errstr;
$sth->execute() || die $sth->errstr;
$row = $sth->fetchrow_hashref;
if (!defined($row))
{
  die "Unknown Architecture $TargetArch\n";
}
else
{
  $TargetArchId = $row->{Aid};
}

LoadMissingData();

# Map of name to run-time name of shared library
local(*LIBMAPFILE);
open(LIBMAPFILE, ">LibNameMap.txt") 
    || die "Could not open file LibNameMap.txt file for writing\n";

# Get list of libraries we want to produce stub libraries for
$sth = $dbh->prepare("SELECT Lid,Lname,Lrunname FROM Library "
                     . "where Library.Lstd='Yes'")
    || die $dbh->errstr;
$sth->execute() || die $sth->errstr;

my($dataAliases);
while ($row = $sth->fetchrow_hashref)
{
  print "Generating c stubs for $row->{Lname} library ($row->{Lrunname})\n";
  print LIBMAPFILE "$row->{Lname} $row->{Lrunname}\n";
#  $dataAliases = GenerateAliases($row->{Lrunname});
  GenerateLibrary($dbh, $row->{Lname}, $row->{Lid});
}


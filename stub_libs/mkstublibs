#!/usr/bin/perl -w

# Tool to generate source code for stub libraries
#
# (C) Copyright 2001 The Free Standards Group  Inc
#
# Chris Yeoh (cyeoh@samba.org), IBM
#
# This is $Revision: 1.1 $
#
# $Log: mkstublibs,v $
# Revision 1.1  2001/08/27 08:01:08  cyeoh
# Adds core files needed for lsb stub library generation
#
#

use strict;
use DBI;
use Getopt::Std;

my($DBName) = "lsb";
my($DBUser) = "";
my($DBPass)  = "";
my($DBHost) = "";
my($TargetArch);
my($TargetArchId);
my(%Options);

######################################################################
# Determine type for an interface given the Ireturn field for it
# Returns a string of the C type
#  sub DetermineType($$)
#  {
#    my($dbh) = shift;
#    my($typeNum) = shift;
#    my($sth);
#    my($row);
  
#    if ($typeNum==0)
#    {
#      print STDERR "Passed type number 0. Using int\n";
#      return "int";
#    }

#    $sth = $dbh->prepare("SELECT Tname,Ttype,Tbasetype from Type where Tid=$typeNum")
#        || die $dbh->errstr;
#    $sth->execute() || die $sth->errstr;

#    $row = $sth->fetchrow_hashref();
#    if (!defined($row))
#    {
#      print "Unable to find type num $typeNum. Making up a value.\n";
#      return "int";
#    }

#    if ($row->{Ttype} eq "Intrinsic")
#    {
#      return $row->{Tname};
#    }
#    elsif ($row->{Ttype} eq "Funcptr" || $row->{Ttype} eq "Pointer")
#    {
#      return "void *";
#    }
#    elsif ($row->{Ttype} eq "Enum")
#    {
#      return "int";
#    }
#    elsif ($row->{Ttype} eq "Typedef")
#    {
#      return DetermineType($dbh, $row->{Tbasetype});
#    }
#    elsif ($row->{Ttype} eq "Struct")
#    {
#      print "Oops. Don't know how to handle a struct\n";
#      return "int";
#    }
#    elsif ($row->{Ttype} eq "Union")
#    {
#      print "Oops. Don't know how to handle a union\n";
#      return "int";
#    }
#    elsif ($row->{Ttype} eq "Unknown")
#    {
#      print "Hey, whats an unknown type doing in the database\n";
#      return "int";
#    }
#    else
#    {
#      print "Unknown Ttype enum: $row->{Ttype}\n";
#      return int;
#    };

#  }

######################################################################
# Generate C stub code for a library
sub GenerateLibrary($$$)
{
  my($dbh) = shift;
  my($libName) = shift;
  my($libId) = shift;
  my($sth);
  my($row);
  my(%versionInfo);
  local(*STUBFILE);
  local(*VERSIONFILE);

  open(STUBFILE, ">$libName.c") || die "Could not open $libName.c to write\n";
  open(VERSIONFILE, ">$libName.Version") 
      || die "Could not open $libName.c to write\n";
  
  # Do functions first
  $sth = $dbh->prepare("SELECT DISTINCT Iname,Vname FROM Interface,LibGroup, ".
                       "LGInt LEFT JOIN Version ON Vid=Iversion ".
                       "WHERE Itype='Function' AND ".
                       "Interface.Iid=LGInt.LGIint AND Istatus='Included'".
                       "AND LGInt.LGIlibg=LibGroup.LGid ".
                       "AND LibGroup.LGlib=$libId ORDER BY Iname")
      || die $dbh->errstr;  
  $sth->execute() || die $sth->errstr;
  while ($row = $sth->fetchrow_hashref())
  {
    print(STUBFILE "void $row->{Iname}(void) {} ;\n");
    if (defined($row->{Vname}))
    {
      # Unversioned symbols will not have the Vname field defined
      if (!defined($versionInfo{$row->{Vname}}))
      {
        $versionInfo{$row->{Vname}} = ();
      }
      push(@{$versionInfo{$row->{Vname}}}, $row->{Iname});
    }
  }

  # Do variables next
  $sth = $dbh->prepare("SELECT DISTINCT Iname,Vname,Ireturn,ATsize FROM ".
                       "Interface,LibGroup,LGInt ".
                       "LEFT JOIN Version ON Vid=Iversion ".
                       "LEFT JOIN ArchType ON ATtid=Ireturn and ".
                       "ATaid=$TargetArchId WHERE ".
                       "Itype='Data' AND Interface.Iid=LGInt.LGIint ".
                       "AND Istatus='Included' ".
                       "AND LGInt.LGIlibg=LibGroup.LGid ".
                       "AND LibGroup.LGlib=$libId ORDER BY Iname")
      || die $dbh->errstr;  
  $sth->execute() || die $sth->errstr;
  my($size);
  while ($row = $sth->fetchrow_hashref())
  {
    # Work out size of data variable
    if (!defined($row->{"ATsize"}))
    {
      print STDERR "Size not available for symbol $row->{Iname}"
          . "  Type ($row->{Ireturn})\n";
      $size = 1000; # temporarily make it big to avoid problems
    }
    elsif ($row->{"ATsize"} == 0)
    {
      print STDERR "Size for symbol $row->{Iname} of Type $row->{Ireturn} is 0\n";
      $size = 1000; # temporarily make it big to avoid problems
    }
    else
    {
      $size = $row->{"ATsize"};
    }
    print(STUBFILE "__asm__(\".comm $row->{Iname},$size\");\n");

    if (defined($row->{Vname}))
    {
      # Unversioned symbols will not have the Vname field defined
      if (!defined($versionInfo{$row->{Vname}}))
      {
        $versionInfo{$row->{Vname}} = ();
      }
      push(@{$versionInfo{$row->{Vname}}}, $row->{Iname});
    }
  }

  # Dump version information
  my($version);
  my($symbol);
  my($symbols);
  print VERSIONFILE "LSB_DUMMY { __LSB_DUMMY; };\n";
  foreach $version (sort keys %versionInfo)
  {
    $symbols = $versionInfo{$version};
    print VERSIONFILE "$version {\n";

    foreach $symbol (@$symbols)
    {
      print VERSIONFILE "  $symbol;\n";
    }
    print VERSIONFILE "};\n";
  }

  close(STUBFILE);
  close(VERSIONFILE);
}


######################################################################
# Main bit
getopts('d:u:p:o:ha:', \%Options);

if (exists($Options{'h'}))
{
  print STDERR <<"EOM"
Usage $0 -a arch [-d db_name] [-u username] [-p password] [-o hostname] [-h]
    -h           Display this help
    -d db_name   Database name
    -u username  Name of user for db access
    -p password  Password for db access
    -o hostname  Hostname for DB
    -a arch      Architecture to generate shared libraries for
                 (Note this is not magic - you have to compile it on
                  the correct platform still!)
EOM
    ;
  exit(1);
}

if (defined($Options{'a'}))
{
  $TargetArch = $Options{'a'};
}
else
{
  die "Must define target architecture\n";
}

$DBUser = $Options{'u'} if exists($Options{'u'});
$DBPass = $Options{'p'} if exists($Options{'p'});
$DBHost = $Options{'o'} if exists($Options{'o'});
$DBName = $Options{'d'} if exists($Options{'d'});

my($dbh);
my($sth);
my($row);
my($data_source) = "DBI:mysql:database=$DBName";
if ($DBHost ne "")
{
  $data_source .= ";host=$DBHost";
}

$dbh = DBI->connect($data_source, $DBUser, $DBPass)
    || die "Could not connect to database\n";


# Get architecture information
$sth = $dbh->prepare("SELECT Aid from Architecture where Aname='$TargetArch'")
    || die $dbh->errstr;
$sth->execute() || die $sth->errstr;
$row = $sth->fetchrow_hashref;
if (!defined($row))
{
  die "Unknown Architecture $TargetArch\n";
}
else
{
  $TargetArchId = $row->{Aid};
}

# Map of name to run-time name of shared library
local(*LIBMAPFILE);
open(LIBMAPFILE, ">LibNameMap.txt") 
    || die "Could not open file LibNameMap.txt file for writing\n";

# Get list of libraries we want to produce stub libraries for
$sth = $dbh->prepare("SELECT Lid,Lname,Lrunname FROM Library "
                     . "where Library.Lstd='Yes'")
    || die $dbh->errstr;
$sth->execute() || die $sth->errstr;

while ($row = $sth->fetchrow_hashref)
{
  print "Generating c stubs for $row->{Lname} library\n";
  print LIBMAPFILE "$row->{Lname} $row->{Lrunname}\n";
  GenerateLibrary($dbh, $row->{Lname}, $row->{Lid});
}


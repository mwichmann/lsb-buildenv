#!/usr/bin/perl -I../

use Getopt::Long;
use DBI;
use specdb;

use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);

# Set to 1 to trace SQL statments
$trace=0;
$specdb::trace=$trace;

# Variable to fix Function pointer hack.
$specdb::typefuncptr=0;
$specdb::funcPtrName="";
$className="";

# variable to resolve typedef stuct/union definition
$semicolonNeeded=0;
$struct_anon_member=0;

# Let's remember LSB version where the header appeared to omit extra checks for LSB version
$header_appin='';

# We can have long chains of inheritance with FuncPtr base (e.g. typedef to pointer to FuncPtr)
# such types cannot be processed in a usual way (i.e. we can't print '*' after FuncPtr declaration.
#  we should place it in brackets inside that declaration)
$deriviation="";

%prototyped = {};
%specdb::processed_typedefs = {};
$specdb::datadef = 0;

sub
usage()
{
die "mkheader -h <headername> -a <archname>";
}

GetOptions("h=s" => \$headname,
        "a=s" => \$archname);

if( !$headname ) { usage(); }
if( !$archname ) { usage(); }

$headname =~ s/^\.\///;
$protect = "_".$headname."_";
$protect =~ tr/[a-z]\.\/[\-]/[A-Z]__[_]/;

$dbh = DBI->connect('DBI:mysql:database='.$LSBDB.';host='.$LSBDBHOST, $LSBUSER, $LSBDBPASSWD)
    or die "Couldn't connect to database: ".DBI->errstr;
$specdb::dbh = $dbh;
specdb::prepareQueries();

#
# Get the Architecture and Header ids
#
$Aid = specdb::getArchitectureId($archname);
if( !$Aid ) {
    $dbh->disconnect;
    exit 0;
}

($Hid, $Hsrcerror) = specdb::getHeaderId($headname,'');
if( !$Hid ) {
    $dbh->disconnect;
    exit 0;
}

$TMaid=$Aid;
$specdb::TMaid = $TMaid;
$specdb::ArchId = $Aid;

sub get_typelist {
    my $sth, $entry, %type, %return_types, %param_types, $typelist = '';
    undef %type;
    undef %return_types;
    undef %param_types;
    my $Query_Hid = $_[0];
    my $ignore_typedefed = $_[1];

    #
    # This next section, which tries to determine all of the types for which
    # a dependency exists could probably be replaced by a loop that repeats until
    # no more new type s are added during a pass.
    #

    #
    # Get the return types and parameter types
    #
    %return_types = specdb::getReturnTypes($Query_Hid, $Aid, "All");
    while( ($k,$v) = each(%return_types) ) {
        $type{$k} = $v;
    }

    %param_types = specdb::getParameterTypes($Query_Hid, $Aid, "All");
    while( ($k,$v) = each(%param_types) ) {
        $type{$k} = $v;
    }

    #
    # Get any other type that is assigned to this header
    #
    $select = "SELECT Tid,Tname FROM Type ";
    $select.= "JOIN HeaderGroup ON Theadgroup=HGid ";
    $select.= "JOIN ArchType ON ATtid=Tid ";
    $select.= "WHERE HGheader=$Query_Hid ";
    $select.= "AND ( (ATappearedin > '' ";
    $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
    $select.= "OR Tindirect='Yes' OR Tsrconly='Yes' OR Tconly='Yes' ) ";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        if ($entry->{'Tid'}) {
            $type{$entry->{'Tid'}}=1;
        }
    }
    $sth->finish;

    $typelist=join ',', keys(%type);

    #
    # Get the base types of Typedefs
    #
    if( !$ignore_typedefed ) {
        if( $typelist ne "" ) {
            $select = "SELECT DISTINCT ATbasetype FROM Type ";
            $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
            $select.= "WHERE Tid IN ($typelist) ";
            $select.= "AND ATbasetype NOT IN ($typelist) ";
            $select.= "AND Ttype = 'Typedef' ";
            print $select,"\n" if $trace;
            $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            for(1..$sth->rows) {
                $entry = $sth->fetchrow_hashref;
                $type{$entry->{'ATbasetype'}}=1;
            }
            $sth->finish;
        }
    }
    $typelist=join ',', keys(%type);

    #
    # Get the base types of Pointers
    #
    if( $typelist ne "" ) {
        $select = "SELECT DISTINCT ATbasetype FROM Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Tid IN ($typelist) ";
        $select.= "AND ATbasetype NOT IN ($typelist) ";
        $select.= "AND Ttype = 'Pointer' ";
        print $select,"\n" if $trace;
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
        for(1..$sth->rows) {
            $entry = $sth->fetchrow_hashref;
            $type{$entry->{'ATbasetype'}}=1;
        }
        $sth->finish;
    }
    $typelist=join ',', keys(%type);

    #
    # Get the base types of Struct/Union/Fptr members
    #
    if( $typelist ne "" ) {
        $select = "SELECT DISTINCT TMtypeid FROM TypeMember ";
        $select.= "WHERE TMmemberof IN ($typelist) "; # here we should process all type members on all archs
        $select.= "AND TMtypeid NOT IN ($typelist) ";
        print $select,"\n" if $trace;
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
        for(1..$sth->rows) {
            $entry = $sth->fetchrow_hashref;
            $type{$entry->{'TMtypeid'}}=1;
        }
        $sth->finish;
    }
    $typelist=join ',', keys(%type);

    #
    # Get the base types of Pointers found in Struct/Union/Fptr members
    #
    if( $typelist ne "" ) {
        $select = "SELECT DISTINCT ATbasetype FROM Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Tid IN ($typelist) ";
        $select.= "AND ATbasetype NOT IN ($typelist) ";
        $select.= "AND Ttype = 'Pointer' ";
        print $select,"\n" if $trace;
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
        for(1..$sth->rows) {
            $entry = $sth->fetchrow_hashref;
            $type{$entry->{'ATbasetype'}}=1;
        }
        $sth->finish;
    }
    $typelist=join ',', keys(%type);

    #
    # Get the base types of Typedefs found in Struct/Union/Fptr members
    #
    if( !$ignore_typedefed ) {
        if( $typelist ne "" ) {
            $select = "SELECT DISTINCT ATbasetype FROM Type ";
            $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
            $select.= "WHERE Tid IN ($typelist) ";
            $select.= "AND ATbasetype NOT IN ($typelist) ";
            $select.= "AND Ttype = 'Typedef' ";
            print $select,"\n" if $trace;
            $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            for(1..$sth->rows) {
                $entry = $sth->fetchrow_hashref;
                $type{$entry->{'ATbasetype'}}=1;
            }
            $sth->finish;
        }
    }

    $typelist=join ',', keys(%type);

    #
    # Get the base types of type we have picked up in the Struct/Union/Fptr members
    #
    if( $typelist ne "" ) {
        $select = "SELECT DISTINCT ATbasetype FROM Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Tid IN ($typelist) ";
        $select.= "AND ATbasetype NOT IN ($typelist) ";
        print $select,"\n" if $trace;
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
        for(1..$sth->rows) {
            $entry = $sth->fetchrow_hashref;
            $type{$entry->{'ATbasetype'}}=1;
        }
        $sth->finish;
    }
    $typelist=join ',', keys(%type);

    #
    # Do this once more to get nested Struct/Unions/Fptr members
    #
    if( !$ignore_typedefed ) {
        if( $typelist ne "" ) {
            $select = "SELECT DISTINCT TMtypeid FROM TypeMember ";
            $select.= "WHERE TMmemberof IN ($typelist)";
            $select.= "AND TMtypeid NOT IN ($typelist) ";
            print $select,"\n" if $trace;
            $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            for(1..$sth->rows) {
                $entry = $sth->fetchrow_hashref;
                $type{$entry->{'TMtypeid'}}=1;
            }
            $sth->finish;
        }

        $typelist=join ',', keys(%type);

        #
        # Get the base types of type we have picked up in the Struct/Union/Fptr members
        #
        if( $typelist ne "" ) {
            $select = "SELECT DISTINCT ATbasetype FROM Type ";
            $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
            $select.= "WHERE Tid IN ($typelist) ";
            $select.= "AND ATbasetype NOT IN ($typelist) ";
            print $select,"\n" if $trace;
            $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            for(1..$sth->rows) {
                $entry = $sth->fetchrow_hashref;
                $type{$entry->{'ATbasetype'}}=1;
            }
            $sth->finish;
        }
    }
    $typelist=join ',', keys(%type);

    if( !$ignore_typedefed ) {
        if( $typelist ne "" ) {
            $select = "SELECT DISTINCT ATbasetype FROM Type ";
            $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
            $select.= "WHERE Tid IN ($typelist) ";
            $select.= "AND ATbasetype NOT IN ($typelist) ";
            print $select,"\n" if $trace;
            $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            for(1..$sth->rows) {
                $entry = $sth->fetchrow_hashref;
                $type{$entry->{'ATbasetype'}}=1;
            }
            $sth->finish;
        }
    }
    $typelist=join ',', keys(%type);

    #
    # Get the base types of Const
    #
    if( $typelist ne "" ) {
        $select = "SELECT DISTINCT ATbasetype FROM Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Tid IN ($typelist) ";
        $select.= "AND Ttype = 'Const' ";
        $select.= "AND ATbasetype NOT IN ($typelist) ";
        print $select,"\n" if $trace;
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
        for(1..$sth->rows) {
            $entry = $sth->fetchrow_hashref;
            $type{$entry->{'ATbasetype'}}=1;
        }
    }
    $sth->finish;

    $typelist=join ',', keys(%type);

    return $typelist;
}

$typelist = get_typelist($Hid,0);
# $param_typelist = $typelist;

# Get Class list

$select = "SELECT * FROM Type ";
$select.= "LEFT JOIN ArchType ON Tid=ATtid ";
$select.= "LEFT JOIN HeaderGroup ON Theadgroup=HGid ";
$select.= "WHERE HGheader=$Hid ";
$select.= "AND (Ttype='Class' ";
$select.= "OR (Ttype='Struct' AND Tclass > 0 AND Tunmangled NOT LIKE '%::%') ) ";
$select.= "AND ATappearedin > '' ";
$select.= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) ";
print $select,"\n" if $trace;
$sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
for(1..$sth->rows) {
    $entry = $sth->fetchrow_hashref;
    if( $entry->{'Tid'} ) {
        $class{$entry->{'Tid'}}=1;
    }
}
$sth->finish;
$classlist=join ',', keys(%class);

if( $classlist ne "" ) {
    $select = "SELECT TMtypeid FROM TypeMember ";
    $select.= "WHERE TMmemberof in ($classlist)";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        if( $entry->{'TMtypeid'} ) {
            $class_member{$entry->{'TMtypeid'}}=1;
        }
    }
    $sth->finish;
    $typelist=join ',', keys(%class_member);
}

#
# Get the headers referenced by 'header_depend' constants values
#

$select = "SELECT ACvalue, ACorder FROM Constant ";
$select.= "LEFT JOIN ArchConst ON Cid=ACcid ";
$select.= "LEFT JOIN HeaderGroup ON Cheadgroup=HGid ";
$select.= "WHERE HGheader=$Hid ";
$select.= "AND Ctype='header_depend' ";
# No check for withdrawn - we don't have any 'header_depend' constants withdrawn before 3.1
$select.= "AND ACappearedin > ''";
print $select,"\n" if $trace;
$sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
for(1..$sth->rows) {
    $entry = $sth->fetchrow_hashref;
    $header{$entry->{'ACvalue'}}=$entry->{'ACorder'};
}
$sth->finish;
$constlist=join '\',\'', keys(%const);

#
# Get LSB versions where this header is allowed in
#
if( $Hsrcerror ne "Yes" ) {
    $select = "SELECT Happearedin, Hwithdrawnin FROM Header WHERE Hid=$Hid ORDER BY Happearedin";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    $index=0;
    $appearedin='';
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        if( $sth->rows == 1 ) {
            # At the moment we don't have headers which appeared twice, but let's prevent possible collisions
            $header_appin = $entry->{'Happearedin'};
            $specdb::header_appin = $entry->{'Happearedin'};
        }
        $appearedin = $entry->{'Happearedin'};
        $appearedin =~ s/\.//;
        $withdrawnin = $entry->{'Hwithdrawnin'};
        $withdrawnin =~ s/\.//;

        if( $index > 0 ) {
            print "|| (__LSB_VERSION__ >= $appearedin ";
        }
        else {
            print "#if (__LSB_VERSION__ >= $appearedin ";
        }

        if( $withdrawnin ) {
            print "&& __LSB_VERSION__ < $withdrawnin";
        }
        print ")";
        $index++;
    }

    $sth->finish;
    print "\n";
}

#
# Set up multiple inclusion protection
#
print "#ifndef $protect\n";
print "#define $protect\n";
print "\n";

#
# Get the headers containing referenced types
#

if( $typelist ne "" ) {
    $select = "SELECT DISTINCT Hid FROM Type ";
    $select.= "LEFT JOIN HeaderGroup ON HGid=Theadgroup ";
    $select.= "LEFT JOIN Header ON Hid=HGheader ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "WHERE Tid IN ($typelist) ";
    $select.= "AND ( (ATappearedin > '' ";
    $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
    $select.= "OR Tindirect='Yes' OR Tsrconly='Yes' OR Tconly='Yes' )";
    $select.= "AND Hid != $Hid ";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        $header{$entry->{'Hid'}}=1;
        }
    }
    $sth->finish;

#
# Output the headers this header needs to include
#
$hdrlist=join ',', keys(%header);
if( $hdrlist ne "" ) {
    $createTmp = "CREATE TEMPORARY TABLE tmp_HeadersDeps ";
    $createTmp.= "(KEY `k_Hid`(`Hid`), KEY `k_ACorder`(`ACorder`,`Hid`)) ";
    $createTmp.= "SELECT DISTINCT Hid, -1 AS ACorder FROM Header ";
    $createTmp.= "WHERE Hid IN ($hdrlist) ";
    $createTmp.= "AND Hid != $Hid ";
    print $createTmp."\n", if $trace;
    $dbh->do($createTmp);

    foreach $dep_hid (keys %header) {
        if( $header{$dep_hid} > 1 ) {
            $dbh->do("UPDATE tmp_HeadersDeps SET ACorder=".$header{$dep_hid}." WHERE Hid=$dep_hid");
        }
    }

    $select = "SELECT Hname, Hid FROM tmp_HeadersDeps ";
    $select.= "JOIN Header USING(Hid) ";
    $select.= "ORDER BY ACorder, Hid ";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        if( $entry->{'Hname'} ) {
            my $header_name = $entry->{'Hname'};
            my $header_id = $entry->{'Hid'};

            #
            # determine if this header depends on
            # any types we are about to declare in this
            # header.
            #
            $header_typelist = get_typelist($entry->{'Hid'},1);
            if ($header_typelist) {
                $select = "SELECT DISTINCT Tid FROM Type ";
                $select.= "LEFT JOIN HeaderGroup ON HGid=Theadgroup ";
                $select.= "LEFT JOIN Header ON Hid=HGheader ";
                $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
                $select.= "WHERE Tid IN ($header_typelist) ";
                $select.= "AND ( (ATappearedin <> '' ";
                $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
                $select.= "OR Tsrconly='Yes' ) ";
                $select.= "AND Hid = $Hid ";
                print $select,"\n" if $trace;
                $sth2 = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
                $sth2->execute or die "Couldn't execute $select query: ".DBI->errstr;
                if ($sth2->rows) {
                    for(1..$sth2->rows) {
                        $header_entry = $sth2->fetchrow_hashref;
                        my $tid = $header_entry->{'Tid'};

                        $$header_name{$tid} = 1;
                        $$tid{$header_name} = 1;
                    }
                } else {
                    print "#include <".$header_name.">\n";
                }
                $sth2->finish;
            } else {
                print "#include <".$header_name.">\n";
            }

        }
    }
    $sth->finish;
}

if( $classlist ne "" ) {
    $select = "SELECT Tname,Tunmangled,Ttype FROM Type ";
    $select.= "WHERE Tid IN (\'$classlist\') ";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        $name = $entry->{'Tunmangled'} ? $entry->{'Tunmangled'} : $entry->{'Tname'};
        $type = ( $entry->{'Ttype'} eq 'Class' ) ? "class" : "struct";
        print "$type $name;\n";
    }
    $sth->finish;
}

# if we have deprecated interfaces inside this header,
#     print LSB_DECL_DEPRECATED macro definition
$selectDepr = "SELECT Iid FROM Interface ";
$selectDepr.= "JOIN ArchInt ON AIint=Iid ";
$selectDepr.= "WHERE Iheader=$Hid ";
$selectDepr.= "AND AIdeprecatedsince IS NOT NULL ";
$selectDepr.= "AND AIappearedin > '' ";
$selectDepr.= "AND (AIwithdrawnin IS NULL OR AIwithdrawnin  > '3.0') ";
$selectDepr.= "LIMIT 1";
print $selectDepr,"\n" if $trace;
my $sthDepr = $dbh->prepare($selectDepr) or die "Couldn't prepare $selectDepr query: ".DBI->errstr;
$sthDepr->execute or die "Couldn't execute $selectDepr query: ".DBI->errstr;

if( $sthDepr->rows ) {
    print "\n";
    print "#if !defined(LSB_DECL_DEPRECATED)\n";
    print "#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && (__GNUC__ - 0 > 3 || (__GNUC__ - 0 == 3 && __GNUC_MINOR__ - 0 >= 2))\n";
    print "#define LSB_DECL_DEPRECATED __attribute__ ((__deprecated__))\n";
    print "#else\n";
    print "#define LSB_DECL_DEPRECATED\n";
    print "#endif\n";
    print "#endif    /* LSB_DECL_DEPRECATED */\n";
}

$sthDepr->finish;

if( !$classlist ) {
    print "\n#ifdef __cplusplus\n";
    print "extern \"C\" {\n";
    print "#endif\n\n";
}
else {
    print "// *INDENT-OFF*\n";
}

if( $Hsrcerror eq 'Yes' ) {
    print "#error \"This header not permitted by the LSB\"\n\n";
}

# dump AbiApi records
$select = "SELECT DISTINCT AAvalue, AAappearedin, AAwithdrawnin FROM AbiApi ";
$select.= "LEFT JOIN Interface ON (Iid=AAbinint OR Iid=AAsrcint) ";
$select.= "WHERE Iheader=$Hid ";
$select.= "AND AAappearedin > '' ";
$select.= "ORDER BY AAappearedin, AAwithdrawnin ";
print $select,"\n" if $trace;
my $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;

my ($oldVersionAppeared, $oldVersionWithdrawn) = ($header_appin,"");

if( $sth->rows ) {
    print "\n";
}
for( 1..$sth->rows ) {
    my $aavalue = $sth->fetchrow_hashref;
    specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $aavalue->{'AAappearedin'}, $aavalue->{'AAwithdrawnin'} );
    $oldVersionAppeared = $aavalue->{'AAappearedin'};
    $oldVersionWithdrawn = $aavalue->{'AAwithdrawnin'};
    print $aavalue->{'AAvalue'}."\n";
}
if( $sth->rows ) {
    print "\n";
    if( $oldVersionWithdrawn ) {
        print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
    }

    if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
        print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
    }

}
$sth->finish;

#
# Get the info from the types in the $type hash
#
# Use the algorithm from admin/headers.php3

$select = "SELECT HGid,HGdescription,HGorder FROM HeaderGroup ";
$select.= "WHERE HGheader=$Hid ";
$select.= "ORDER BY HGorder";
print $select,"\n" if $trace;
$hgh = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$hgh->execute or die "Couldn't execute $select query: ".DBI->errstr;

for(1..$hgh->rows) {
    $entry = $hgh->fetchrow_hashref;
    $HGid=$entry->{'HGid'};
    $HGdesc=$entry->{'HGdescription'};
    $HGorder=$entry->{'HGorder'};
    # Make sure a blank line is present between every group
    print "\n";
    $specdb::HGid = $HGid;

    # Since it's a header, document it
    if( $HGorder != 0 && $HGdesc ne "" ) {
        print "/* ".$HGdesc."*/\n";
    }

    # Display the Constants
    #
    # Display the Constants excluding the generated header
    # dependency constants
    #
    $select = "SELECT * FROM Constant ";
    $select.= "LEFT JOIN ArchConst ON Cid=ACcid ";
    $select.= "LEFT JOIN Architecture ON Aid=ACaid ";
    $select.= "WHERE Cheadgroup=$HGid ";
    $select.= "AND ACappearedin > '' ";
    $select.= "AND (ACwithdrawnin IS NULL OR ACwithdrawnin > '3.0') ";
    $select.= "AND Ctype != 'header_depend'";
    $select.=" ORDER BY ACappearedin, ACwithdrawnin, ACorder, ACvalue, Cname, Aid";
    $ch = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $ch->execute or die "Couldn't execute $select query: ".DBI->errstr;
    print $ch->rows," rows\n" if $trace;

    $oldVersionAppeared = $header_appin;
    $oldVersionWithdrawn = '';

    for(1..$ch->rows) {
        $centry = $ch->fetchrow_hashref;

        specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $centry->{'ACappearedin'}, $centry->{'ACwithdrawnin'});
        $oldVersionWithdrawn = $centry->{'ACwithdrawnin'};
        $oldVersionAppeared = $centry->{'ACappearedin'};

        # If it's architecture sensitive, add the #if's to
        # make it work correctly.
        if( $centry->{'Aid'} && $centry->{'Aname'} ne "All" ) {
            print "#if ".$centry->{'Asymbol'}."\n";
            specdb::displayconstant($centry);
            print "#endif\n";
        } else {
            specdb::displayconstant($centry);
        }
    }
    $ch->finish;

    if( $oldVersionWithdrawn ) {
        print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
    }
    if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
        print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
    }

    if( $ch->rows ) {
        print "\n\n";
    }

    %processedNames;

    # Display the Type (Typedef)
    $select = "SELECT * FROM Type ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "LEFT JOIN Architecture ON ATaid=Aid ";
    $select.= "WHERE Theadgroup=$HGid ";
    $select.= "AND ( (ATappearedin<>'' ";
    $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
    $select.= "OR Tsrconly = 'Yes' OR Tconly = 'Yes' ) ";
    $select.= "AND Ttype = 'Typedef' ";
    $select.= "AND Tclass = 0 ";
#   $select.= "AND Aid = $Aid ";
    # Potential problem, if we have inconsistencies among type and its base 'appearedin'
    $select.= "ORDER BY ATappearedin, ATwithdrawnin, Tid";
    print $select,"\n" if $trace;
    $th = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $th->execute or die "Couldn't execute $select query: ".DBI->errstr;
    print $th->rows," rows\n" if $trace;

    $oldVersionWithdrawn = "";
    $oldVersionAppeared = $header_appin;

    for(1..$th->rows) {
        $tentry = $th->fetchrow_hashref;

        if( $specdb::processed_typedefs{$tentry->{'Tid'}} ) {
            next;
        }

        if( $tentry->{'Aname'} ne "All" ) {
            if( specdb::isGenericTypePresent($tentry->{'Tid'}, "All") ) {
                next;
            }
        }
        specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $tentry->{'ATappearedin'}, $tentry->{'ATwithdrawnin'});
        $oldVersionWithdrawn = $tentry->{'ATwithdrawnin'};
        $oldVersionAppeared = $tentry->{'ATappearedin'};

        $TMaid = $tentry->{'Aid'} ? $tentry->{'Aid'} : $Aid;
        $specdb::TMaid = $TMaid;
        if( $tentry->{'Tconly'} eq "Yes" ) {
            print "#if !defined(__cplusplus)\n";
        }
        if( $tentry->{'Aid'} && $tentry->{'Aname'} ne "All" ) {
            print "#if ".$tentry->{'Asymbol'}."\n";
            print "/* ".$tentry->{'Aname'}." */\n";
            specdb::displaytype($tentry,0);
            print ";";
            if( $tentry->{'Tdescription'} ) {
                print "/* ".$tentry->{'Tdescription'}." */";
            }
            print "\n\n#endif\n";
        } else {
            specdb::displaytype($tentry,0);
            print ";";
            if( $tentry->{'Tdescription'} ) {
                print "/* ".$tentry->{'Tdescription'}." */";
            }
            print "\n\n";
        }
        if( $tentry->{'Tconly'} eq "Yes" ) {
            print "#endif\n";
        }

        # Display headers now that we've declared their
        # dependant types.
        foreach $header_name (keys %{$tentry->{'Tid'}}) {
            if (1 == scalar (keys %$header_name)) {
                print "#include <" . $header_name . ">\n";
            }
            delete $$header_name{$tentry->{'Tid'}};
        }
    }
    $th->finish;

    if( $oldVersionWithdrawn ) {
        print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
    }
    if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
        print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
    }

    $oldVersionWithdrawn = "";
    $oldVersionAppeared = $header_appin;

    # Display the Types (excluding Typedef)
#   if( !$param_typelist ) {
#       $param_typelist = "0";
#   }
    $select = "SELECT * FROM Type ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "LEFT JOIN Architecture ON ATaid=Aid ";
#   $select.= "LEFT JOIN Parameter ON Ptype=Tid ";
#   $select.= "LEFT JOIN Interface ON Iid=Pint ";
    $select.= "WHERE Theadgroup=$HGid ";
    $select.= "AND ( (ATappearedin > '' ";
    $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
#   $select.= "OR ( Tid IN ($param_typelist) AND Ttype IN ('Struct','Union','Enum') AND Tname NOT LIKE 'anon%' )";
    $select.= "OR Tsrconly = 'Yes' OR Tconly = 'Yes' ) ";
    $select.= "AND Ttype != 'Typedef' ";
    $select.= "AND (Tclass=0 OR Ttype='Struct' OR Ttype='Class') ";
#   $select.= "AND Aid = $Aid ";
    $select.= "ORDER BY ATappearedin, ATwithdrawnin, Tid";
    print $select,"\n" if $trace;
    $th = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $th->execute or die "Couldn't execute $select query: ".DBI->errstr;
    print $th->rows," rows\n" if $trace;
    for(1..$th->rows) {
        $tentry = $th->fetchrow_hashref;

        if( $tentry->{'Aname'} ne "All" ) {
            # Check for included generic records
            if( specdb::isGenericTypePresent($tentry->{'Tid'}, "All" ) ) {
                next;
            }

            # Are we processing not-included not-generic type that came from param_typelist?
#           $select = "SELECT ATtid FROM ArchType LEFT JOIN Type ON ATtid=Tid ";
#           $select.= "WHERE Tid IN ($param_typelist) AND Ttype IN ('Struct','Union','Enum') AND ATaid=1 ";
#           $thArchSpec = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
#           $thArchSpec->execute or die "Couldn't execute $select query: ".DBI->errstr;
#           if( $thArchSpec->rows ) {
#               $thArchSpec->finish;
#               next;
#           }
#           $thArchSpec->finish;
        }

        if( $processedNames{($tentry->{'Tid'},$tentry->{'Aid'})} ) {
            next;
        }

        if( $processedNames{($tentry->{'Tid'},1)} ) {
            next;
        }

        $TMaid = $tentry->{'Aid'} ? $tentry->{'Aid'} : $Aid;
        $specdb::TMaid = $TMaid;

        specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $tentry->{'ATappearedin'}, $tentry->{'ATwithdrawnin'});
        $oldVersionWithdrawn = $tentry->{'ATwithdrawnin'};
        $oldVersionAppeared = $tentry->{'ATappearedin'};

        if( $tentry->{'Tconly'} eq "Yes" ) {
            print "#if !defined(__cplusplus)\n";
        }
        if( $tentry->{'Aid'} && $tentry->{'Aname'} ne "All" ) {
            print "#if ".$tentry->{'Asymbol'}."\n";
            print "/* ".$tentry->{'Aname'}." */\n";
            specdb::displaytype($tentry,0);
            print ";";
            if( $tentry->{'Tdescription'} ) {
                print "/* ".$tentry->{'Tdescription'}." */";
            }
            print "\n\n#endif\n";
        } else {
            specdb::displaytype($tentry,0);
            print ";";
            if( $tentry->{'Tdescription'} ) {
                print "/* ".$tentry->{'Tdescription'}." */";
            }
            print "\n\n";
        }
        if( $tentry->{'Tconly'} eq "Yes" ) {
            print "#endif\n";
        }

#       $processedNames{($tentry->{'Tid'},$Aid)} = 1;
        $processedNames{($tentry->{'Tid'},$tentry->{'Aid'})} = 1;
        $processedNamesOnly{$tentry->{'Tid'}} = 1;

        # Display headers now that we've declared their
        # dependant types.
        foreach $header_name (keys %{$tentry->{'Tid'}}) {
            if (1 == scalar (keys %$header_name)) {
                print "#include <" . $header_name . ">\n";
            }
            delete $$header_name{$tentry->{'Tid'}};
        }
    }
    $th->finish;

    if( $oldVersionWithdrawn ) {
        print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
    }
    if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
        print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
    }

    $oldVersionWithdrawn = "";
    $oldVersionAppeared = $header_appin;

    # Display the Types (Struct/Union)
    $select = "SELECT * FROM Type ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "LEFT JOIN Architecture ON ATaid=Aid ";
    $select.= "WHERE Theadgroup=$HGid ";
    $select.= "AND ( (ATappearedin > '' ";
    $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
    $select.= "OR Tsrconly = 'Yes' OR Tconly = 'Yes' ) ";
    $select.= "ORDER BY ATappearedin, ATwithdrawnin, Tid";
    print $select,"\n" if $trace;

    $th = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $th->execute or die "Couldn't execute $select query: ".DBI->errstr;
    print $th->rows," rows\n" if $trace;

    for(1..$th->rows) {
        $tentry = $th->fetchrow_hashref;
        if( $tentry->{'Aname'} ne "All" ) {
            if( specdb::isGenericTypePresent($tentry->{'Tid'}, "All") ) {
                next;
            }
        }

        if( $tentry->{'Ttype'} eq "Typedef" ) {
            $OldAid = $Aid;
            # Check if generic record for the basetype presents
            if( specdb::isGenericTypePresent($tentry->{'ATbasetype'}, "All") ) {
                $Aid=1;
            }
            else {
                $Aid = $tentry->{'Aid'};
            }
            $specdb::ArchId = $Aid;

            # Maybe the necessary basetype has already been processed?
            #~ if( $processedNamesOnly{$tentry->{'ATbasetype'}} ) {
            if( $processedNames{($tentry->{'ATbasetype'},$Aid)} ) {
                next;
            }

            $processedNames{($tentry->{'ATbasetype'},$Aid)} = 1;
            $processedNamesOnly{$tentry->{'ATbasetype'}} = 1;
            #~ $processedNames{$tentry->{'ATbasetype'},1} = 1;

            $tselect = "SELECT * FROM Type LEFT JOIN HeaderGroup ON Theadgroup=HGid ";
            $tselect.= "JOIN TypeMember ON TMmemberof=Tid "; # Straight join here; no need to declare structs without members
            $tselect.= "WHERE Tid=".$tentry->{'ATbasetype'};
            $tselect.= " AND ( Ttype='Struct' OR Ttype='Union' ) AND HGheader=$Hid AND Tname NOT LIKE 'anon%' ";

            $tth = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
            $tth->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
            if($tth->rows) {
                $semicolonNeeded = 1;
                specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $tentry->{'ATappearedin'}, $tentry->{'ATwithdrawnin'});
                $oldVersionWithdrawn = $tentry->{'ATwithdrawnin'};
                $oldVersionAppeared = $tentry->{'ATappearedin'};
                $ttentry = $tth->fetchrow_hashref;
                $TMaid = $tentry->{'Aid'} ? $tentry->{'Aid'} : $Aid;
                $specdb::TMaid = $TMaid;

                if( $ttentry->{'Tconly'} eq "Yes" ) {
                    print "#if !defined(__cplusplus)\n";
                }
                if( $tentry->{'Aid'} && $tentry->{'Aname'} ne "All" ) {
                    print "#if ".$tentry->{'Asymbol'}."\n";
                    print "/* ".$tentry->{'Aname'}." */\n";
                    specdb::displaytype($ttentry,0);
                    if ($semicolonNeeded) {
                        $semicolonNeeded = 0;
                        print ";";
                    }
                    if( $ttentry->{'Tdescription'} ) {
                        print "/* ".$ttentry->{'Tdescription'}." */";
                    }
                    print "\n\n#endif\n";
                } else {
                    specdb::displaytype($ttentry,0);
                    if ($semicolonNeeded) {
                        $semicolonNeeded = 0;
                        print ";";
                    }
                    if( $ttentry->{'Tdescription'} ) {
                        print "/* ".$ttentry->{'Tdescription'}." */";
                    }
                    print "\n\n";
                }
                if( $ttentry->{'Tconly'} eq "Yes" ) {
                    print "#endif\n";
                }
            }
            $tth->finish;
            $Aid = $OldAid;
            $specdb::ArchId = $Aid;
        }

        # Display headers now that we've declared their
        # dependant types.
        foreach $header_name (keys %{$tentry->{'Tid'}}) {
            # To actually dump the #include directive, we must ensure that there is only one dep
            # left and this dep is satisfied by this Tid
            if (1 == scalar (keys %$header_name) and (keys %$header_name == $tentry->{'Tid'}) ) {
                print "#include <" . $header_name . ">\n";
            }
            delete $$header_name{$tentry->{'Tid'}};
        }
    }
    $th->finish;

    if( $oldVersionWithdrawn ) {
        print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
    }
    if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
        print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
    }

}
$hgh->finish;
#
# Dump out the function prototypes
#

$select = "SELECT * FROM Interface ";
$select.= "LEFT JOIN Type ON Ireturn=Tid ";
$select.= "LEFT JOIN ArchInt ON Iid=AIint ";
$select.= "LEFT JOIN ArchType ON ATtid=Tid AND ATaid=AIarch ";
$select.= "LEFT JOIN Architecture ON AIarch=Aid ";
$select.= "WHERE Iheader=$Hid ";
$select.= "AND (Isrcbin='SrcOnly' ";
$select.= " OR ( (Isrcbin='Both' OR Iid IN ( ";
$select.= "  SELECT AAbinint FROM AbiApi ";
$select.= "  WHERE AAappearedin > '' ";
$select.= "  AND AAwithdrawnin IS NULL "; # No check for 3.0, there were no AbiApi there
$select.= ")) AND ";
$select.= "AIappearedin > '' AND (AIwithdrawnin IS NULL OR AIwithdrawnin > '3.0') ) ";
$select.= ") ";
# Hope check for libstdcxx is temporary and will be eliminated when we get more
# graceful c++ headers generators
$select.= "AND (Iclass=0 OR Ilibrary='libstdcxx') ";
$select.= "ORDER BY AIappearedin, AIwithdrawnin, Iname ";
print $select,"\n" if $trace;
$sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;

if( $sth->rows ) {
    print "\n/* Function prototypes */\n\n";
}

$oldVersionAppeared = $header_appin;
$oldVersionWithdrawn = '';

for(1..$sth->rows) {
    $entry = $sth->fetchrow_hashref;

    if( $entry->{'Aid'} != 1 ) {
        $selectGeneric = "SELECT Iid FROM Interface ";
        $selectGeneric.= "LEFT JOIN ArchInt ON Iid=AIint ";
        $selectGeneric.= "WHERE AIarch=1 AND AIint='$entry->{'AIint'}'";
        $selectGeneric.= "AND (Isrcbin='SrcOnly' ";
        $selectGeneric.= "OR ( (Isrcbin='Both' OR Iid IN ( ";
        $selectGeneric.= " SELECT AAbinint FROM AbiApi ";
        $selectGeneric.= " WHERE AAappearedin > '' ";
        $selectGeneric.= " AND AAwithdrawnin IS NULL ";
        $selectGeneric.= ")) AND ";
        $selectGeneric.= "AIappearedin > '' ";
        $selectGeneric.= "AND (AIwithdrawnin IS NULL OR AIwithdrawnin >'3.0') ) ) ";
        $selectGeneric.= "LIMIT 1";
        $sthGeneric = $dbh->prepare($selectGeneric) or die "Couldn't prepare $selectGeneric query: ".DBI->errstr;
        $sthGeneric->execute or die "Couldn't execute $selectGeneric query: ".DBI->errstr;
        if( $sthGeneric->rows ) {
            $sthGeneric->finish;
            next;
        }
        $sthGeneric->finish;
    }

    # Check, if this interface is overridden through the AbiApi table.
    # If so, provide the prototype only for those versions where it is not overridden.
    $selectSrcInt = "SELECT AAappearedin, AAwithdrawnin FROM AbiApi ";
    $selectSrcInt.= "WHERE AAsrcint=".$entry->{'Iid'};
    $srcth = $dbh->prepare($selectSrcInt) or die "Couldn't prepare $selectSrcInt query".DBI->errstr;
    $srcth->execute or die "Couldn't execute $selectSrcInt query: ".DBI->errstr;
    if( $srcth->rows ) {
        $srcentry = $srcth->fetchrow_hashref;
        $srcAppearedin = $srcentry->{'AAappearedin'};
        $srcAwithdrawnin = $srcentry->{'AAwithdrawnin'};
        specdb::printLsbVersionBounds('','',$srcAwithdrawnin,$srcAppearedin);
    }
    else {
        $srcAppearedin = $srcWithdrawnin = '';
    }
    $srcth->finish;

    if( $entry->{'Isrcbin'} ne 'SrcOnly' ) {
        specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $entry->{'AIappearedin'}, $entry->{'AIwithdrawnin'});
        $oldVersionAppeared = $entry->{'AIappearedin'};
        $oldVersionWithdrawn = $entry->{'AIwithdrawnin'};
    }
    else {
        if( $oldVersionWithdrawn ) {
            print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
            $oldVersionWithdrawn = '';
        }

        if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
            print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
            $oldVersionAppeared = '';
        }
    }

    # Check if we have a macro with the same name; undef, if any
    $macroName = $entry->{'Iname'};
    $macroName =~ s/_/\\_/g;
    $checkMacro = "SELECT Cid FROM Constant ";
    $checkMacro.= "JOIN ArchConst ON ACcid=Cid ";
    $checkMacro.= "WHERE Cname LIKE '$macroName(%' ";
    $checkMacro.= "AND ACappearedin > '' ";
    $checkMacro.= "AND (ACwithdrawnin IS NULL OR ACwithdrawnin > '3.0') ";
    $checkMacro.= "LIMIT 1";
    $cth = $dbh->prepare($checkMacro) or die "Couldn't prepare $checkMacro query".DBI->errstr;
    $cth->execute or die "Couldn't execute $checkMacro query: ".DBI->errstr;
    if( $cth->rows ) {
        print "#undef ".$entry->{'Iname'}."\n";
    }
    $cth->finish;

    specdb::display_interface($entry);

    if( $srcAppearedin ) {
        print "#endif /* __LSB_VERSION__ < $srcAppearedin */\n\n";
    }
    if( $srcWithdrawnin ) {
        print "#endif /* __LSB_VERSION__ >= $srcWithdrawnin */\n\n";
    }
}
$sth->finish;

if( $oldVersionWithdrawn ) {
    print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
}

if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
    print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
}

if( !$classlist ) {
    print "#ifdef __cplusplus\n";
    print "}\n";
    print "#endif\n";
}
else {
    print "// *INDENT-ON*\n";
}
print "#endif /* protection */\n";

if( $Hsrcerror ne "Yes" ) {
    print "#endif /* LSB version */\n";
}

specdb::finishQueries();
$dbh->disconnect;


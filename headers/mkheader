#!/usr/bin/perl -I../

use Getopt::Long;
use DBI;
use specdb;

use Env qw(LSBUSER LSBDBPASSWD LSBDB LSBDBHOST);

# Set to 1 to trace SQL statments
$trace=0;
$specdb::trace=$trace;

$nameonly=0;

# Variable to fix Function pointer hack.
$typefuncptr=0;
$funcPtrName="";
$className="";

# variable to resolve typedef stuct/union definition
$typeflag=0;
$semicolonNeeded=0;
$struct_anon_member=0;

# Let's remember LSB version where the header appeared to omit extra checks for LSB version
$header_appin='';

# We can have long chains of inheritance with FuncPtr base (e.g. typedef to pointer to FuncPtr)
# such types cannot be processed in a usual way (i.e. we can't print '*' after FuncPtr declaration.
#  we should place it in brackets inside that declaration)
$deriviation="";

%prototyped = {};
%processed_typedefs = {};

sub
usage()
{
die "mkheader -h <headername> -a <archname> -v <lsbversion>";
}

sub
displaytype($)
{
local ($type) = @_;
local (*entry,*tentry,*tmentry,*dtentry);
local($th);
local($tmh, $dth, $dsth);

# handle opaque types better ...
if ($nameonly && $$type{'Ttype'} eq "") {
    print $$type{'Tname'};
    return;
}

if( $$type{'Ttype'} eq "Intrinsic" ) {
    print $$type{'Tname'}."\t";
    return;
}

if( $$type{'Ttype'} eq "Literal" ) {
    print $$type{'Tname'};
    return;
}

if( $$type{'Ttype'} eq "Volatile" ) {
    $basetype = specdb::getBaseTypeID($type);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $entry = $sth->fetchrow_hashref;
    $sth->finish;
    if( $entry->{'Ttype'} eq "Pointer" ) {
        displaytype($entry);
        print "volatile ";
    } else {
        print "volatile ";
        displaytype($entry);
    }
    return;
}

if( $$type{'Ttype'} eq "Const" ) {
    $basetype = specdb::getBaseTypeID($type);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $entry = $sth->fetchrow_hashref;
    $sth->finish;
    if( $entry->{'Ttype'} eq "Pointer" ) {
        displaytype($entry);
        print "const ";
    } else {
        print "const ";
        displaytype($entry);
    }
    return;
}

if( $$type{'Ttype'} eq "Typedef" ) {
    if (!$nameonly && !$typeflag) {
        print "typedef ";
        $typefuncptr=0;
    }
    $basetype = specdb::getBaseTypeID($type);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $entry = $sth->fetchrow_hashref;
    $sth->finish;

    local $RootBase = specdb::calculateInitialBaseType($Aid,$basetype);

    if( $RootBase eq 'FuncPtr' && !$nameonly ) {
        $typefuncptr=1;
        $deriviation.= " ".$$type{'Tname'};
        if( $entry->{'Ttype'} eq 'Array' ) {
            $deriviation.= "[".$entry->{'ATsize'}."]";
        }
    }

    #~ if($entry->{'Ttype'} eq "FuncPtr" && !$nameonly) {
        #~ $typefuncptr=1;
    #~ }
# Something about anon or not & wether to set nameonly
    if ($typeflag) {
            if($entry->{'Ttype'} eq 'Struct' || $entry->{'Ttype'} eq 'Union') {
            if( $entry->{'Tname'} !~ "anon" and $entry->{'Theadgroup'} == $HGid ) {
                        displaytype($entry);
            }
        } else {
            return;
        }
    } elsif (!$nameonly) {
        if( ( $entry->{'Ttype'} eq 'Typedef' || $entry->{'Ttype'} eq 'FuncPtr' ||
                $entry->{'Ttype'} eq 'Function' ) || $entry->{'Theadgroup'} != $HGid ) {
            if($entry->{'Ttype'} eq 'FuncPtr' || $entry->{'Ttype'} eq 'Function') {
                #~ $funcPtrName = $$type{'Tname'};
                $funcPtrName = '';
            }
            $nameonly=1;
            displaytype($entry);
            $nameonly=0;
        } elsif( ($entry->{'Ttype'} eq 'Struct' ||
            $entry->{'Ttype'} eq 'Union' )
            && $entry->{'Theadgroup'} == $HGid  ) {
                if( !($entry->{'Tname'} =~ "anon" )) {
                    $nameonly=1;
                    displaytype($entry);
                    $nameonly=0;
                } else {
                    displaytype($entry);
                }
        } else {
            displaytype($entry);
        }
    }
    if( ($entry->{'Ttype'} ne 'Function' and $entry->{'Ttype'} ne 'FuncPtr' and $RootBase ne 'FuncPtr' ) || $nameonly ) {
        if(!$typeflag) {
            $typedef_name = $$type{'Tunmangled'} ? $$type{'Tunmangled'} : $$type{'Tname'};

            if( $typedef_name =~ /$className\:\:(.+)/ ) {
                $typedef_name = $1;
            }

            print $typedef_name."\t";
        }
    }
    if( $entry->{'Ttype'} eq 'Array' && $nameonly==0 && $RootBase ne 'FuncPtr') {
        print "[".$entry->{'ATsize'}."]";
    }
    if( !$nameonly && $$type{'ATattribute'} && !$typeflag ) {
        print "__attribute__ (".$$type{'ATattribute'}.")";
    }
    if (!$nameonly) {
        if( $$type{'Tdescription'} ) {
            print "/* ".$$type{'Tdescription'}." */";
        }
        print "\n";
    }

    # We can have different typedefs on the same anonymous enum;
    # let's print declarations of all such enums in one place,
    # without redeclaring enum members
    if( $entry->{'Ttype'} eq 'Enum' and !$entry->{'Tname'} ) {
        $DervidedTypes = $entry->{'Tid'};
        #~ local (*deriviations);
        $deriviations{$entry->{'Tid'}} = "";
        $cur_deriviation = "";

        $lastType = $entry->{'Tid'};
        while( $lastType ) {
            $calcDerivedTypes = "SELECT Tid FROM Type ";
            $calcDerivedTypes.= "LEFT JOIN ArchType ON ATtid=Tid ";
            $calcDerivedTypes.= "WHERE Ttype = 'Pointer' AND ATbasetype = $lastType ";
            print $calcDerivedTypes."\n" if($trace);
            $dth = $dbh->prepare($calcDerivedTypes) or die "Couldn't prepare $calcDerivedTypes query: ".DBI->errstr;
            $dth->execute or die "Couldn't execute $calcDerivedTypes query: ".DBI->errstr;
            if( $dth->rows ) {
                $dtentry = $dth->fetchrow_hashref;
                $DervidedTypes.= ", ".$dtentry->{'Tid'};
                $lastType = $dtentry->{'Tid'};
                $cur_deriviation.= '*';
                $deriviations{$lastType} = $cur_deriviation;
            }
            else {
                $lastType = 0;
            }
            $dth->finish;
        }

        $select = "SELECT * FROM Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Theadgroup = $HGid ";
        $select.= "AND Tid != ".$$type{'Tid'}." ";
        $select.= "AND Ttype = 'Typedef' ";
        $select.= "AND ATappearedin > '' ";
        $select.= "AND ATbasetype IN ($DervidedTypes) ";
        $select.= "GROUP BY Tid ";
        print $select."\n" if ($trace);
        $dsth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $dsth->execute or die "Couldn't execute $select query: ".DBI->errstr;

        for( 1..$dsth->rows ) {
            $dtentry = $dsth->fetchrow_hashref;
            print ", ";
            print $deriviations{$dtentry->{'ATbasetype'}};
            print $dtentry->{'Tname'};
            $processed_typedefs{$dtentry->{'Tid'}} = 1;
        }
        $dsth->finish;
    }

    return;
}

if( $$type{'Ttype'} eq "Pointer" or $$type{'Ttype'} eq "Ref" ) {
    $basetype = specdb::getBaseTypeID($type);
    $tth = specdb::getBaseTypeRecord($Aid,$basetype);
    $RootBase = specdb::calculateInitialBaseType($Aid,$basetype);

    if( $RootBase eq 'FuncPtr' ) {
        if( $$type{'Ttype'} eq "Ref" ) {
            $deriviation = "&".$deriviation;
        }
        else {
            $deriviation = "*".$deriviation;
        }
    }

    $entry = $tth->fetchrow_hashref;
    $tth->finish;
    if (!$nameonly) {
        if( $entry->{'Ttype'} eq 'Typedef' ||
            $entry->{'Ttype'} eq 'FuncPtr' ) {
            $nameonly=1;
            displaytype($entry);
            $nameonly=0;
        } else {
            if (($entry->{'Ttype'} eq 'Struct' || $entry->{'Ttype'} eq 'Union') && !$typeflag ) {
               $nameonly=1;
               displaytype($entry);
               $nameonly=0;
            } else {
                displaytype($entry);
            }
        }
    } else {
        displaytype($entry);
    }

    if( $RootBase ne 'FuncPtr' ) {
        if( $$type{'Ttype'} eq "Ref" ) {
            print "& ";
        }
        else {
            print "* ";
        }
    }
    return;
}

if( $$type{'Ttype'} eq "Struct" and ($$type{'Tclass'} == 0 or $$type{'Tunmangled'} =~ "::") ) {
    if( $$type{'Tname'} =~ "anon" ) {
        $$type{'Tname'} ="";
        $nameonly = 0;
        }
    $struct_name = $$type{'Tunmangled'} ? $$type{'Tunmangled'} : $$type{'Tname'};

    if( $struct_name =~ /$className\:\:(.+)/ ) {
        $struct_name = $1;
    }

    if (!$typeflag){
        print "struct ".$struct_name."\t";
    }
    if( $nameonly ) { return; }
    $Tid=$$type{'Tid'};
    #print $$type{'Tdescription'}."\n";

    $tmselect = "SELECT distinct TypeMember.*,TMEdeclaration FROM TypeMember ";
    $tmselect.= "LEFT JOIN TypeMemberExtras ON TMEtmid=TMid ";
    $tmselect.= "WHERE TMmemberof=$Tid AND TMaid IN (1,$TMaid) ";
    $tmselect.= "ORDER BY TMposition";
    $tmh = $dbh->prepare($tmselect) or die "Couldn't prepare $tmselect query: ".DBI->errstr;
    $tmh->execute or die "Couldn't execute $tmselect query: ".DBI->errstr;
    if ($tmh->rows ) {
        if ($typeflag){
            print "\nstruct ".$$type{'Tname'}."\t";
            $semicolonNeeded=1;
        }
        print "{\n";
    }
    for(1..$tmh->rows) {
        $tmentry = $tmh->fetchrow_hashref;
        if( $tmentry->{'TMEdeclaration'} ) {
            print $tmentry->{'TMEdeclaration'}."\n";
            next;
        }
        $TMtypeid=$tmentry->{'TMtypeid'};
        #joining Type table with ArchType to get ATsize value for Array bounds.
        $tselect = "SELECT * FROM Type ";
        $tselect.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $tselect.= "WHERE Tid=$TMtypeid ";
#       $tselect.= "AND ATaid=$Aid";
#       print $tselect."\n";
        $th = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
        $th->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
        $entry = $th->fetchrow_hashref;
        $th->finish;
        $nameonly=1;
        if($typeflag){
            $typeflag=0;
            $sflag=1;
        }
        $funcPtrName = $tmentry->{'TMname'};

#       if( $tmentry->{'Aid'} && $tmentry->{'Aname'} ne "All" ) {
#           print "#if defined(".$tmentry->{'Asymbol'}.")\n";
#       }
        if( !$tmentry->{'TMname'} ) {
            $struct_anon_member=1;
        }
        displaytype($entry);
        $struct_anon_member=0;
        if( $entry->{'Ttype'} ne 'FuncPtr' ) {
            print $tmentry->{'TMname'};
            }
        # Adding code to support both values from TMarray and ATsize for Array bounds.
        # TMarray condition should be removed once we deprecate it.
        if( $entry->{'Ttype'} eq 'Array' ) {
            if($tmentry->{'TMarray'}){
                print "[".$tmentry->{'TMarray'}."]";
            }else {
                # check the basetype of this array
                $tselect ="SELECT * FROM Type ";
                $tselect.= "LEFT JOIN ArchType ON ATtid=Tid ";
                $tselect.="WHERE Tid=$entry->{'ATbasetype'} ";
                $tth = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
                $tth->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
                $bentry = $tth->fetchrow_hashref;
                $tth->finish;
                if ($bentry->{'Ttype'} eq 'Array') {
                    print "[".$bentry->{'ATsize'}."]"."[".$entry->{'ATsize'}."]";
                } elsif( $entry->{'ATsize'} > 0 ) {
                    print "[".$entry->{'ATsize'}."]";
        } else {
            print "[]";
        }
            }
        }
        if( $tmentry->{'TMbitfield'} != 0 ) {
            print ":".$tmentry->{'TMbitfield'};
        }
        print ";\t";
        if( $tmentry->{'TMdescription'} ) {
            print "/* ".$tmentry->{'TMdescription'}." */";
        }
        print "\n";
#       if( $tmentry->{'Aid'} && $tmentry->{'Aname'} ne "All" ) {
#           print "#endif /* ".$tmentry->{'Asymbol'}." */\n";
#       }
        $nameonly=0;
        if( $sflag ) {
            $typeflag=1;
            $sflag=0;
        }
    }
    if ($tmh->rows ) { print "}\n"; }
    if( $$type{'ATattribute'} ) {
        print "__attribute__ (".$$type{'ATattribute'}.")";
    }
#   print "\n";
    $tmh->finish;
    return;
}

if( $$type{'Ttype'} eq "Union" ) {

    if( $$type{'Tname'} =~ "anon" ) {
        $$type{'Tname'} ="";
        $nameonly = 0;
    }

    $union_name = $$type{'Tunmangled'} ? $$type{'Tunmangled'} : $$type{'Tname'};

    if( $union_name =~ /$className\:\:(.+)/ ) {
        $union_name = $1;
    }

    if(!$typeflag) {
        if( $struct_anon_member and !$union_name ) {
            print "__extension__ ";
        }
        print "union ".$union_name."\t";
    }

    $Tid=$$type{'Tid'};
    if( $nameonly ) { return; }
    #print $$type{'Tdescription'}."\n";

    $tmselect = "SELECT distinct TypeMember.*, TMEdeclaration FROM TypeMember ";
    $tmselect.= "LEFT JOIN TypeMemberExtras ON TMEtmid=TMid ";
    $tmselect.= "WHERE TMmemberof=$Tid AND TMaid IN(1,$TMaid) ";
    $tmselect.= "ORDER BY TMposition";
    $tmh = $dbh->prepare($tmselect) or die "Couldn't prepare $tmselect query: ".DBI->errstr;
    $tmh->execute or die "Couldn't execute $tmselect query: ".DBI->errstr;
    if ($tmh->rows ) {
        if($typeflag){
            print "union ".$$type{'Tname'}."\t";
            $semicolonNeeded=1;
        }
        print "{\n";
    }
    for(1..$tmh->rows) {
        $tmentry = $tmh->fetchrow_hashref;
        if( $tmentry->{'TMEdeclaration'} ) {
            print $tmentry->{'TMEdeclaration'}."\n";
            next;
        }
        $TMtypeid=$tmentry->{'TMtypeid'};
        $tselect="SELECT * FROM Type ";
        $tselect.="LEFT JOIN ArchType ON ATtid=Tid ";
        $tselect.="WHERE Tid=$TMtypeid ";
#       $tselect.= "AND ATaid=$Aid";
        $th = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
        $th->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
        $entry = $th->fetchrow_hashref;
        $th->finish;
        $nameonly=1;
        if($typeflag){
            $typeflag=0;
            $uflag=1;
        }
        $funcPtrName = $tmentry->{'TMname'};

        displaytype($entry);
        if( $entry->{'Ttype'} ne 'FuncPtr' ) {
            print $tmentry->{'TMname'};
        }
        if( $entry->{'Ttype'} eq 'Array' ) {
            if($tmentry->{'TMarray'}){
                print "[".$tmentry->{'TMarray'}."]";
            }else{
                # check the basetype of this array
                $tselect="SELECT * FROM Type ";
                $tselect.= "LEFT JOIN ArchType ON ATtid=Tid ";
                $tselect.="WHERE Tid=$entry->{'ATbasetype'} ";
#               $tselect.= "AND ATaid=$Aid";
                $tth = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
                $tth->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
                $bentry = $tth->fetchrow_hashref;
                $tth->finish;
                if ($bentry->{'Ttype'} eq 'Array') {
                    print "[".$bentry->{'ATsize'}."]"."[".$entry->{'ATsize'}."]";
                } else {
                    print "[".$entry->{'ATsize'}."]";
                }

            }
        }
        print ";\t";
        if( $tmentry->{'TMdescription'} ) {
            print "/* ".$tmentry->{'TMdescription'}." */";
        }
        print "\n";
        if($uflag){
            $typeflag=1;
            $uflag=0;
        }
        $nameonly=0;
    }
    if ($tmh->rows ) { print "}\n"; }
    $tmh->finish;
    return;
}

if( $$type{'Ttype'} eq "Enum" ) {
    print "enum ";
    $Tid=$$type{'Tid'};
    if( $$type{'Tname'} =~ "anon" ) {
        $$type{'Tname'} ="";
    }

    $enum_name = $$type{'Tunmangled'} ? $$type{'Tunmangled'} : $$type{'Tname'};

    if( $enum_name =~ /$className\:\:(.+)/ ) {
        $enum_name = $1;
    }

    print $enum_name."\t";
    if( $nameonly and $enum_name ) { return; }
    if( $$type{'Tdescription'} and !$nameonly ) {
        print "/* ".$$type{'Tdescription'}." */";
    }
    print "\n";

    $tmselect = "SELECT * FROM TypeMember WHERE TMmemberof=$Tid AND TMaid IN (1,$TMaid) ";
    $tmselect.= "ORDER BY TMposition";
    $tmh = $dbh->prepare($tmselect) or die "Couldn't prepare $tmselect query: ".DBI->errstr;
    $tmh->execute or die "Couldn't execute $tmselect query: ".DBI->errstr;

    # Is it enum with arch specific contents?
    if (!$tmh->rows ) {
        $tmh->finish;
        $tmselect = "SELECT * FROM TypeMember ";
        $tmselect.= "LEFT JOIN Architecture ON Aid=TMaid ";
        $tmselect.= "WHERE TMmemberof=$Tid ";
        $tmselect.= "ORDER BY TMaid,TMposition ";
        $tmh = $dbh->prepare($tmselect) or die "Couldn't prepare $tmselect query: ".DBI->errstr;
        $tmh->execute or die "Couldn't execute $tmselect query: ".DBI->errstr;
    }

    if ($tmh->rows ) { print "{\n"; }

    $prevArch=0;

    for(1..$tmh->rows) {
        $tmentry = $tmh->fetchrow_hashref;

        if( ($TMaid == 1) and ($tmentry->{'TMaid'} != 1) ) {
            if( $prevArch != $tmentry->{'TMaid'} ) {
                if( $prevArch != 0 ) {
                    print "#endif\n";
                }
                print "#if ".$tmentry->{'Asymbol'}."\n";
                print "/* ".$tmentry->{'Aname'}." */\n";
                $prevArch = $tmentry->{'TMaid'};
            }
        }

        # It's an enum, don't print out the types, just the names
        print $tmentry->{'TMname'};

        # An array doesn't make sense for an enum, so use this to
        # specify a fixed value.
#       if( $tmentry->{'TMarray'} ne '' ) {
#           print " = ".$tmentry->{'TMarray'};
#       }
        if( $tmentry->{'TMvalue'} ne '' ) {
            print " = ".$tmentry->{'TMvalue'};
        }
        if( $_ != $tmh->rows ) {
            print ",\t";
        }
        if( $tmentry->{'TMdescription'} ) {
            print "/* ".$tmentry->{'TMdescription'}."*/";
        }
        print "\n";
        $nameonly=0;

    }
    if( $prevArch != 0 ) {
        print "#endif\n";
    }
    if ($tmh->rows ) { print "}\n"; }
    $tmh->finish;
    return;
}

if( $$type{'Ttype'} eq "FuncPtr" || $$type{'Ttype'} eq "Function" ) {
    $basetype = specdb::getBaseTypeID($type);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $entry = $sth->fetchrow_hashref;
    $sth->finish;
    if( !$nameonly ) {
        $nameonly=1;
        displaytype($entry);
        $nameonly=0;
    } else {
        displaytype($entry);
    }
    print "(*$deriviation" if ($$type{'Ttype'} eq "FuncPtr");
    $deriviation = "";
    $Tid=$$type{'Tid'};
    print $funcPtrName;
    print ")" if ($$type{'Ttype'} eq "FuncPtr");
    if( $$type{'Tdescription'} ) {
        print "/* ".$$type{'Tdescription'}." */";
    }
    print "(";

    $tmselect = "SELECT * FROM TypeMember WHERE TMmemberof=$Tid AND TMaid IN (1,$TMaid) ";
    $tmselect.= "ORDER BY TMposition";
    $tmh = $dbh->prepare($tmselect) or die "Couldn't prepare $tmselect query: ".DBI->errstr;
    $tmh->execute or die "Couldn't execute $tmselect query: ".DBI->errstr;
    if($tmh->rows == 0) {
        print "void";
    }
    for(1..$tmh->rows) {
        $tmentry = $tmh->fetchrow_hashref;
        $TMtypeid=$tmentry->{'TMtypeid'};
        $tselect="SELECT * FROM Type ";
        $tselect.="LEFT JOIN ArchType ON ATtid=Tid ";
        $tselect.="WHERE Tid=$TMtypeid ";
#       $tselect.= "AND ATaid=$Aid";
        $th = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
        $th->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
        $entry = $th->fetchrow_hashref;
        $th->finish;
        $nameonly=1;
        displaytype($entry);
        print $tmentry->{'TMname'};
        if( $tmentry->{'Ttype'} eq 'Array' ) {
            if( $tmentry->{'TMarray'} ) {
                print "[".$tmentry->{'TMarray'}."]";
            }elsif($entry->{'ATsize'}){
                # check the basetype of this array
                $tselect="SELECT * FROM Type ";
                $tselect.= "LEFT JOIN ArchType ON ATtid=Tid ";
                $tselect.="WHERE Tid=$entry->{'ATbasetype'} ";
#               $tselect.= "AND ATaid=$Aid";
                $tth = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
                $tth->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
                $bentry = $tth->fetchrow_hashref;
                $tth->finish;
                if ($bentry->{'Ttype'} eq 'Array') {
                    print "[".$bentry->{'ATsize'}."]"."[".$entry->{'ATsize'}."]";
                } else {
                      print "[".$entry->{'ATsize'}."]";
                }
            }
        }
        if( $_ != $tmh->rows ) {
            print ",";
        }
        $nameonly=0;
    }
    print ")";
    $tmh->finish;
    return;
}

if( $$type{'Ttype'} eq "Array" ) {
    $basetype = specdb::getBaseTypeID($type);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $entry = $sth->fetchrow_hashref;
    $sth->finish;
    if( !$nameonly ) {
        $nameonly=1;
        displaytype($entry);
        $nameonly=0;
    } else {
        displaytype($entry);
    }

    return;
}

# structures in cpp can also have methods; such structures are stored as classes, not like usual classes
if( ( $$type{'Ttype'} eq "Struct" and $$type{'Tclass'} != 0 and $$type{'Tunmangled'} !~ "::" ) or ( $$type{'Ttype'} eq "Class" ) ) {
#if( $$type{'Ttype'} eq "Class" ) {
    $cselect ="SELECT * FROM ClassInfo ";
    $cselect.="WHERE CItid=".$$type{'Tid'};
#   $cselect.= "AND ATaid=$Aid";
    $cth = $dbh->prepare($cselect) or die "Couldn't prepare $cselect query: ".DBI->errstr;
    $cth->execute or die "Couldn't execute $cselect query: ".DBI->errstr;
    $entry = $cth->fetchrow_hashref;
    if( !$cth->rows ) {
        # No ClassInfo record found for 'Class' type - well, nothing strange, indeed.
        # This means we simply have nothing to say about this class (usually because the class is internal
        # and users should not call its methods directly)
        $cth->finish;
        return;
    }
    $cth->finish;
    $CIid=$entry->{'CIid'};

    $name = $$type{'Tunmangled'} ? $$type{'Tunmangled'} : $$type{'Tname'};

    if( $nameonly ) {
        print "$name ";
        return;
    }

    if( $$type{'Ttype'} eq 'Class' ) {
        print "class $name";
    }
    else {
        print "struct $name";
    }
#   if( $nameonly ) {
#       return;
#   }

    if( $entry->{'CInumvmitypes'} ) {
        $selectVMI = "SELECT Iunmangled,VBTaccess FROM VMIBaseTypes ";
        $selectVMI.= "LEFT JOIN Interface ON Iid=VBTbasetype ";
        $selectVMI.= "WHERE VBTcid=".$entry->{'CIid'}." GROUP BY Iunmangled";
        $vmi = $dbh->prepare($selectVMI) or die "Couldn't prepare $selectVMI query: ".DBI->errstr;
        $vmi->execute or die "Couldn't execute $selectVMI query: ".DBI->errstr;
        $printed=0;
        for(1..$vmi->rows) {
            $rowVMI = $vmi->fetchrow_hashref;

            $rowVMI->{'Iunmangled'} =~ s/typeinfo for //;
            $Name = $rowVMI->{'Iunmangled'};
            $access = $rowVMI->{'VBTaccess'};

            if( $printed ) {
                print(", ");
            }
            else {
                print( " : " );
                $printed = 1 ;
            }

            if( $Name ) {
                print( $access." ".$Name );
            }
        }
        $vmi->finish;
    }
    elsif( $entry->{'CInumbasetype'} == 1 ) {
        $selectBase = "SELECT Iunmangled,BTaccess FROM BaseTypes ";
        $selectBase.= "LEFT JOIN Interface ON Iid=BTbasetype ";
        $selectBase.= "WHERE BTcid=".$entry->{'CIid'};
        $base = $dbh->prepare($selectBase) or die "Couldn't prepare $selectBase query: ".DBI->errstr;
        $base->execute or die "Couldn't execute $selectBase query: ".DBI->errstr;
        $rowBase = $base->fetchrow_hashref;
        $base->finish;
        $rowBase->{'Iunmangled'} =~ s/typeinfo for //;
        $Name = $rowBase->{'Iunmangled'};
        $access = $rowBase->{'BTaccess'};
        print( " : $access ".$Name );
    }

    print "\n";
    print "{\n";

    $old_access="";

    # declare members; there is no 'member access type' support in the db schema now, so all
    # struct members will be public and class members will be private
    if( $$type{'Ttype'} eq 'Class' ) {
        $old_access="private";
        print "private:\n";
    }
    else { # struct
        $old_access="public";
        print "public:\n";
    }

    $select = "SELECT * FROM TypeMember ";
    $select.= "LEFT JOIN Type ON TMtypeid=Tid ";
    $select.= "WHERE TMmemberof=".$$type{'Tid'};
    print $select,"\n" if $trace;
    $tmh = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $tmh->execute or die "Couldn't execute $select query: ".DBI->errstr;
    print $tmh->rows," rows\n" if $trace;
    for(1..$tmh->rows) {
        $typeflag=0;
        $tmentry = $tmh->fetchrow_hashref;
        $nameonly = 1;
        print "    ";
        $old_CIid = $CIid;
        $old_name = $name;
        displaytype($tmentry);
        $name = $old_name;
        $CIid = $old_CIid;
        print " ".$tmentry->{'TMname'}.";\n";
        $nameonly = 0;
    }
    $tmh->finish;

    # all types declared here will be in public section
    if( $$type{'Ttype'} eq 'Class' ) {
        $old_access="public";
        print "public:\n";
    }

    # Display class internal types
    $select = "SELECT * FROM Type ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "LEFT JOIN Architecture ON ATaid=Aid ";
    $select.= "WHERE Tclass=$CIid ";
    # skip classes themselves
    if( $$type{'Ttype'} eq 'Class' ) {
        $select.= "AND Ttype<>'Class' ";
    }
    else {
        $select.= "AND Ttype<>'Struct' ";
    }
    $select.= "AND ( ( (ATappearedin <= '$lsbversion' and ATappearedin<>'') ";
    $select.= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin >'$lsbversion') ) ";
    $select.= "OR Tsrconly = 'Yes' OR Tconly = 'Yes' ) ";
#   $select.= "AND Aid = $Aid ";
    $select.= "ORDER BY Tid";
    print $select,"\n" if $trace;

    $th = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $th->execute or die "Couldn't execute $select query: ".DBI->errstr;
    print $th->rows," rows\n" if $trace;
    for(1..$th->rows) {
        $typeflag=0;
        $tentry = $th->fetchrow_hashref;
        if( $tentry->{'Aname'} ne "All" ) {
            if( specdb::isGenericTypePresent($tentry->{'Tid'}, $lsbversion) ) {
                next;
            }
        }

        $old_CIid = $CIid;
        $old_name = $name;
        $className = $name;
        $TMaid = $tentry->{'Aid'} ? $tentry->{'Aid'} : $Aid;
        if( $tentry->{'Aid'} && $tentry->{'Aname'} ne "All" ) {
            print "#if ".$tentry->{'Asymbol'}."\n";
            print "/* ".$tentry->{'Aname'}." */\n";
            displaytype(tentry);
            print ";";
            if( $tentry->{'Tdescription'} ) {
                print "/*".$tentry->{'Tdescription'}." */";
            }
            print "\n\n#endif\n";
        } else {
            displaytype(tentry);
            print ";";
            if( $tentry->{'Tdescription'} ) {
                print "/* ".$tentry->{'Tdescription'}." */";
            }
            print "\n\n";
        }
        $name = $old_name;
        $CIid = $old_CIid;
    }
    $th->finish;

    # Display class interfaces
    $iselect = "SELECT * FROM Interface ";
    $iselect.= "LEFT JOIN Type ON Ireturn=Tid ";
    $iselect.= "LEFT JOIN ArchInt ON Iid=AIint ";
    $iselect.= "LEFT JOIN Architecture ON AIarch=Aid ";
    $iselect.= "LEFT JOIN ArchType ON ATtid=Tid AND ATaid=AIarch ";
    $iselect.= "WHERE Iclass=".$$type{'Tid'}." ";
    $iselect.= "AND Iunmangled not like '%thunk%' ";
    $iselect.= "AND (Isrcbin='SrcOnly' OR (";
    $iselect.= "(AIappearedin <= '$lsbversion' and AIappearedin<>'') ";
    $iselect.= "AND (AIwithdrawnin IS NULL OR AIwithdrawnin >'$lsbversion') ) ) ";
    $iselect.=" ORDER BY Iaccess";
    print $iselect,"\n" if $trace;

    %processed = ();
    $ith = $dbh->prepare($iselect) or die "Couldn't prepare $iselect query: ".DBI->errstr;
    $ith->execute or die "Couldn't execute $iselect query: ".DBI->errstr;
    for(1..$ith->rows) {
        $int = $ith->fetchrow_hashref;

        if( $int->{'Aid'} != 1 ) {
            $selectGeneric = "SELECT Iid FROM Interface ";
            $selectGeneric.= "LEFT JOIN ArchInt ON Iid=AIint ";
            $selectGeneric.= "WHERE AIarch=1 AND Iname='$int->{'Iname'}'";
            $selectGeneric.= "AND (Isrcbin='SrcOnly' OR (";
            $selectGeneric.= "(AIappearedin <= '$lsbversion' and AIappearedin<>'') ";
            $selectGeneric.= "AND (AIwithdrawnin IS NULL OR AIwithdrawnin >'$lsbversion') ) ) ";
            $sthGeneric = $dbh->prepare($selectGeneric) or die "Couldn't prepare $selectGeneric query: ".DBI->errstr;
            $sthGeneric->execute or die "Couldn't execute $selectGeneric query: ".DBI->errstr;
            if( $sthGeneric->rows ) {
                $sthGeneric->finish;
                next;
            }
            $sthGeneric->finish;
        }

        $Iid = $int->{'Iid'};
        $Itype = $int->{'Itype'};
        $Iaccess = $int->{'Iaccess'};
        $Istatic = $int->{'Istatic'};
        $Ivirtual = $int->{'Ivirtual'};

        if( $$type{'Ttype'} eq 'Class' and $Iaccess ne $old_access ) {
            print $Iaccess.":\n";
            $old_access = $Iaccess;
        }

        if( $Itype eq 'Data' ) {
            $unmangled = $int->{'Iunmangled'};
            if( $unmangled =~ /$name\:\:(.+)/ ) {
                $unmangled = $1;
            }

            $rselect = "SELECT * FROM Type LEFT JOIN ArchType ON ATtid=Tid WHERE Tid = ".$int->{'Ireturn'};
            $rth = $dbh->prepare($rselect) or die "Couldn't prepare $rselect query: ".DBI->errstr;
            $rth->execute or die "Couldn't execute $rselect query: ".DBI->errstr;
            if($rth->rows) {
                $ret = $rth->fetchrow_hashref;
                $old_name = $name;
                $nameonly = 1;
                print "    ";
                displaytyperef($ret);
                $nameonly = 0;
                $name = $old_name;
            }
            $rth->finish;

            print " $unmangled;\n";
            next;
        }

#       $Iname = $int->{'Ishortname'};
#       if( !$Iname ) {
#           print STDERR "Please set Ishortname for interface with Iid=".$int->{'Iid'}."\n";
#           $Iname = $int->{'Iunmangled'} ? $int->{'Iunmangled'} : $int->{'Iname'};
#       }

        if( $int->{'Iunmangled'} ) {
            $unmangled = $int->{'Iunmangled'};
            if( $unmangled =~ /$name\:\:(.+)/ ) {
                $unmangled = $1;
            }

            # On binary level, there can be several contructors and destructors, coming
            # from the same source level interface
            if( $processed{"$unmangled"} ) {
                next;
            }
            $processed{"$unmangled"} = 1;

            print "    ";
            if( $Ivirtual eq 'Yes' ) {
                print "virtual ";
            }
            if( $Istatic eq 'Yes' ) {
                print "static ";
            }
            $old_name = $name;
            displaytyperef($int);
            $name = $old_name;
            print " ";
            print $unmangled.";\n";
        }
        else {
            print STDERR "Couldn't find unmangled name for Interface ".$int->{'Iid'}."\n";
        }
    }
    $ith->finish;

    print "}";
    return;
}

if( $$type{'Ttype'} eq "TemplateInstance" ) {
    print $$type{'Tunmangled'};
    return;
}

print "Unknown Type: \".$$type{'Ttype'}.\"\n";
}

sub
displaytyperef($)
{
local ($param) = @_;
local(%select,$sth,$type);

if( $$param{'Ttype'} eq "Intrinsic" ) {
    print $$param{'Tname'};
    return;
}

if( $$param{'Ttype'} eq "Literal" ) {
    print $$param{'Tname'};
    return;
}

if( $$param{'Ttype'} eq "Volatile" ) {
    $basetype = specdb::getBaseTypeID($param);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $type = $sth->fetchrow_hashref;
    $sth->finish;
    if( $type->{'Ttype'} eq "Pointer" || $type->{'Ttype'} eq "Array") {
        displaytyperef($type);
        print " volatile ";
    } else {
        print "volatile ";
        displaytyperef($type);
    }
    return;
}

if( $$param{'Ttype'} eq "Const" ) {
    $basetype = specdb::getBaseTypeID($param);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $type = $sth->fetchrow_hashref;
    $sth->finish;
    if( $type->{'Ttype'} eq "Pointer" || $type->{'Ttype'} eq "Array") {
        displaytyperef($type);
        print " const ";
    } else {
        print "const ";
        displaytyperef($type);
    }
    return;
}

if( $$param{'Ttype'} eq "Pointer" ) {
    $basetype = specdb::getBaseTypeID($param);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $type = $sth->fetchrow_hashref;
    $sth->finish;
    displaytyperef($type);
    print " *";
    return;
}

if( $$param{'Ttype'} eq "Struct" ) {
    $struct_name = $$param{'Tunmangled'} ? $$param{'Tunmangled'} : $$param{'Tname'};

    if( $struct_name =~ /$className\:\:(.+)/ ) {
        $struct_name = $1;
}

    print "struct ".$struct_name;
    return;
}

if( $$param{'Ttype'} eq "Typedef" ) {
    print $$param{'Tname'};
    return;
}

if( $$param{'Ttype'} eq "Union" ) {
    print "union ".$$param{'Tname'};
    return;
}

if( $$param{'Ttype'} eq "Enum" ) {
    print "enum ".$$param{'Tname'};
    return;
}

if( $$param{'Ttype'} eq "Array" ) {
    $basetype = specdb::getBaseTypeID($param);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $type = $sth->fetchrow_hashref;
    $sth->finish;
    if( !$nameonly ) {
        $nameonly=1;
        displaytyperef($type);
        $nameonly=0;
    } else {
        displaytyperef($type);
    }
#   if( $$param{'Tname'} =~ "fptr" ) {
#       $$param{'Tname'} =~ s/fptr-//;
#   }
    return;
}

if( $$param{'Ttype'} eq "FuncPtr" ) {
    $basetype = specdb::getBaseTypeID($param);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $type = $sth->fetchrow_hashref;
    $sth->finish;
    $Tid=$$param{'Tid'};
    displaytyperef($type);
    print "(*$funcPtrName";
    # commenting below code as $$param{'Tname'} is not printed/commented
#   if( $$param{'Tname'} =~ "fptr" ) {
#       $$param{'Tname'} =~ s/fptr-//;
#   }
#   print $$param{'Tname'};
    if( $funcPtrName ) {
        return;
    }
    print ")";
    print "(";

    $tmselect = "SELECT * FROM TypeMember WHERE TMmemberof=$Tid AND TMaid IN (1,$TMaid) ";
    $tmselect.= "ORDER BY TMposition";
    $tmh = $dbh->prepare($tmselect) or die "Couldn't prepare $tmselect query: ".DBI->errstr;
    $tmh->execute or die "Couldn't execute $tmselect query: ".DBI->errstr;
    if($tmh->rows == 0) {
        print "void";
    }
    for(1..$tmh->rows) {
        $tmentry = $tmh->fetchrow_hashref;
        $TMtypeid=$tmentry->{'TMtypeid'};
        $tselect="SELECT * FROM Type ";
        $tselect.="LEFT JOIN ArchType ON ATtid=Tid ";
        $tselect.="WHERE Tid=$TMtypeid ";
        $tselect.="AND ATaid IN($Aid,1) GROUP BY Tid ";
        $th = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
        $th->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
        $entry = $th->fetchrow_hashref;
        $th->finish;
        $nameonly=1;
        displaytype($entry);
#       print $tmentry->{'TMname'};
        if($entry->{'Ttype'} eq 'Array') {
            if( $tmentry->{'TMarray'} ) {
                print "[".$tmentry->{'TMarray'}."]";
            }else{
                print "[".$entry->{'ATsize'}."]";
            }
        }
        if( $_ != $tmh->rows ) {
            print ",";
        }
        $nameonly=0;
    }

    print ")\n";
    $tmh->finish;
    return;
}

if( $$param{'Ttype'} eq "Class" ) {
    $name = $$param{'Tunmangled'} ? $$param{'Tunmangled'} : $$param{'Tname'};
    print $name;
    return;
}

if( $$param{'Ttype'} eq "Ref" ) {
    $basetype = specdb::getBaseTypeID($param);
    $sth = specdb::getBaseTypeRecord($Aid,$basetype);
    $type=$sth->fetchrow_hashref;
    $sth->finish;
    displaytyperef($type);
    print " &";
    return;
}


print $$param{'Ttype'};
}

GetOptions("h=s" => \$headname,
        "v=s" => \$lsbversion,
        "a=s" => \$archname);

if( !$headname ) { usage(); }
if( !$archname ) { usage(); }
if( !$lsbversion ) { usage(); }

$headname =~ s/^\.\///;
$protect = "_".$headname."_";
$protect =~ tr/[a-z]\.\/[\-]/[A-Z]__[_]/;

$dbh = DBI->connect('DBI:mysql:database='.$LSBDB.';host='.$LSBDBHOST, $LSBUSER, $LSBDBPASSWD)
    or die "Couldn't connect to database: ".DBI->errstr;
$specdb::dbh = $dbh;

#
# Get the Architecture and Header ids
#
$Aid = specdb::getArchitectureId($archname);
if( !$Aid ) {
    $dbh->disconnect;
    exit 0;
}

($Hid, $Hsrcerror) = specdb::getHeaderId($headname,'');
if( !$Hid ) {
    $dbh->disconnect;
    exit 0;
}

$TMaid=$Aid;

sub get_typelist {
    my $sth, $entry, %type, %return_types, %param_types, $typelist = '';
    undef %type;
    undef %return_types;
    undef %param_types;
    my $Query_Hid = $_[0];
    my $ignore_typedefed = $_[1];

    #
    # This next section, which tries to determine all of the types for which
    # a dependency exists could probably be replaced by a loop that repeats until
    # no more new type s are added during a pass.
    #

    #
    # Get the return types and parameter types
    #
#   %return_types = specdb::getReturnTypes($Query_Hid, $Aid, $lsbversion);
    %return_types = specdb::getReturnTypes($Query_Hid, $Aid, "All");
    while( ($k,$v) = each(%return_types) ) {
        $type{$k} = $v;
    }

#   %param_types = specdb::getParameterTypes($Query_Hid, $Aid, $lsbversion);
    %param_types = specdb::getParameterTypes($Query_Hid, $Aid, "All");
    while( ($k,$v) = each(%param_types) ) {
        $type{$k} = $v;
    }

    #
    # Get any other type that is assigned to this header
    #
    $select = "SELECT Tid,Tname FROM Type ";
    $select.= "LEFT JOIN HeaderGroup ON Theadgroup=HGid ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "WHERE HGheader=$Query_Hid ";
    $select.= "AND ( (ATappearedin <>'' ";
    $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
    $select.= "OR Tindirect='Yes' OR Tsrconly='Yes' OR Tconly='Yes' ) ";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        if ($entry->{'Tid'}) {
            $type{$entry->{'Tid'}}=1;
        }
    }
    $sth->finish;

    $typelist=join ',', keys(%type);
    #
    # Get the base types of Typedefs
    #

    if( !$ignore_typedefed ) {
        if( $typelist ne "" ) {
            $select = "SELECT ATbasetype,Tname FROM Type ";
            $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
            $select.= "WHERE Tid IN ($typelist) ";
            $select.= "AND ATbasetype NOT IN ($typelist) ";
            $select.= "AND Ttype = 'Typedef' ";
            print $select,"\n" if $trace;
            $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            for(1..$sth->rows) {
                $entry = $sth->fetchrow_hashref;
                $type{$entry->{'ATbasetype'}}=1;
            }
            $sth->finish;
        }
    }

    $typelist=join ',', keys(%type);

    #
    # Get the base types of Pointers
    #

    if( $typelist ne "" ) {
        $select = "SELECT ATbasetype,Tname FROM Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Tid IN ($typelist) ";
        $select.= "AND ATbasetype NOT IN ($typelist) ";
        $select.= "AND Ttype = 'Pointer' ";
        print $select,"\n" if $trace;
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
        for(1..$sth->rows) {
            $entry = $sth->fetchrow_hashref;
            $type{$entry->{'ATbasetype'}}=1;
        }
        $sth->finish;
    }

    $typelist=join ',', keys(%type);

    #
    # Get the base types of Struct/Union/Fptr members
    #

    if( $typelist ne "" ) {
        $select = "SELECT distinct TMtypeid FROM TypeMember ";
        $select.= "WHERE TMmemberof IN ($typelist) "; # here we should process all type members on all archs
        $select.= "AND TMtypeid NOT IN ($typelist) ";
        print $select,"\n" if $trace;
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
        for(1..$sth->rows) {
            $entry = $sth->fetchrow_hashref;
            $type{$entry->{'TMtypeid'}}=1;
            #print STDERR "TypeMember ".$entry->{'TMname'}."\n";
        }
        $sth->finish;
    }

    $typelist=join ',', keys(%type);

    #
    # Get the base types of Pointers found in Struct/Union/Fptr members
    #

    if( $typelist ne "" ) {
        $select = "SELECT ATbasetype,Tname FROM Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Tid IN ($typelist) ";
        $select.= "AND ATbasetype NOT IN ($typelist) ";
        $select.= "AND Ttype = 'Pointer' ";
        print $select,"\n" if $trace;
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
        for(1..$sth->rows) {
            $entry = $sth->fetchrow_hashref;
            $type{$entry->{'ATbasetype'}}=1;
            #print STDERR "Pointer ".$entry->{'Tname'}."\n";
        }
        $sth->finish;
    }

    $typelist=join ',', keys(%type);

    #
    # Get the base types of Typedefs found in Struct/Union/Fptr members
    #
    if( !$ignore_typedefed ) {
        if( $typelist ne "" ) {
            $select = "SELECT ATbasetype,Tname FROM Type ";
            $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
            $select.= "WHERE Tid IN ($typelist) ";
            $select.= "AND ATbasetype NOT IN ($typelist) ";
            $select.= "AND Ttype = 'Typedef' ";
            print $select,"\n" if $trace;
            $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            for(1..$sth->rows) {
                $entry = $sth->fetchrow_hashref;
                $type{$entry->{'ATbasetype'}}=1;
    #           print STDERR "Typedef ".$entry->{'Tname'}."\n";
            }
            $sth->finish;
        }
    }

    $typelist=join ',', keys(%type);

    #
    # Get the base types of type we have picked up in the Struct/Union/Fptr members
    #
    if( $typelist ne "" ) {
        $select = "SELECT ATbasetype,Tname FROM Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Tid IN ($typelist) ";
        $select.= "AND ATbasetype NOT IN ($typelist) ";
        print $select,"\n" if $trace;
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
        for(1..$sth->rows) {
            $entry = $sth->fetchrow_hashref;
            $type{$entry->{'ATbasetype'}}=1;
            #print STDERR "Type ".$entry->{'Tname'}."\n";
        }
        $sth->finish;
    }

    $typelist=join ',', keys(%type);
    #
    # Do this once more to get nested Struct/Unions/Fptr members
    #

    if( !$ignore_typedefed ) {
        if( $typelist ne "" ) {
            $select = "SELECT TMtypeid,TMname FROM TypeMember ";
            $select.= "WHERE TMmemberof IN ($typelist)";
            $select.= "AND TMtypeid NOT IN ($typelist) ";
            print $select,"\n" if $trace;
            $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            for(1..$sth->rows) {
                $entry = $sth->fetchrow_hashref;
                $type{$entry->{'TMtypeid'}}=1;
            }
            $sth->finish;
        }

        $typelist=join ',', keys(%type);

        #
        # Get the base types of type we have picked up in the Struct/Union/Fptr members
        #
        if( $typelist ne "" ) {
            $select = "SELECT ATbasetype,Tname FROM Type ";
            $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
            $select.= "WHERE Tid IN ($typelist) ";
            $select.= "AND ATbasetype NOT IN ($typelist) ";
            print $select,"\n" if $trace;
            $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            for(1..$sth->rows) {
                $entry = $sth->fetchrow_hashref;
                $type{$entry->{'ATbasetype'}}=1;
                #print STDERR "Type2 ".$entry->{'Tname'}."\n";
            }
            $sth->finish;
        }
    }

    $typelist=join ',', keys(%type);

    if( !$ignore_typedefed ) {
        if( $typelist ne "" ) {
            $select = "SELECT ATbasetype,Tname FROM Type ";
            $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
            $select.= "WHERE Tid IN ($typelist) ";
            $select.= "AND ATbasetype NOT IN ($typelist) ";
            print $select,"\n" if $trace;
            $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
            for(1..$sth->rows) {
                $entry = $sth->fetchrow_hashref;
                $type{$entry->{'ATbasetype'}}=1;
                #print STDERR "Type3 ".$entry->{'Tname'}."\n";
            }
            $sth->finish;
        }
    }
    $typelist=join ',', keys(%type);

    #
    # Get the base types of Const
    #

    if( $typelist ne "" ) {
        $select = "SELECT ATbasetype,Tname FROM Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Tid IN ($typelist) ";
        $select.= "AND Ttype = 'Const' ";
        $select.= "AND ATbasetype NOT IN ($typelist) ";
        print $select,"\n" if $trace;
        $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
        for(1..$sth->rows) {
            $entry = $sth->fetchrow_hashref;
            $type{$entry->{'ATbasetype'}}=1;
            #print "Pointer ".$entry->{'Tname'}."\n";
            }
        }
        $sth->finish;

    $typelist=join ',', keys(%type);

    return $typelist;
}

$typelist = get_typelist($Hid,0);
# $param_typelist = $typelist;

# Get Class list

$select = "SELECT * FROM Type ";
$select.= "LEFT JOIN ArchType ON Tid=ATtid ";
$select.= "LEFT JOIN HeaderGroup ON Theadgroup=HGid ";
$select.= "WHERE HGheader=$Hid ";
$select.= "AND (Ttype='Class' ";
$select.= "OR (Ttype='Struct' AND Tclass<>0 AND Tunmangled NOT LIKE '%::%') ) ";
$select.= "AND ( (ATappearedin <> ''";
$select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
$select.= " OR Tsrconly='Yes' ) ";
print $select,"\n" if $trace;
$sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
for(1..$sth->rows) {
    $entry = $sth->fetchrow_hashref;
    if( $entry->{'Tid'} ) {
        $class{$entry->{'Tid'}}=1;
    }
}
$sth->finish;
$classlist=join ',', keys(%class);

if( $classlist ne "" ) {
    $select = "SELECT TMtypeid FROM TypeMember ";
    $select.= "WHERE TMmemberof in ($classlist)";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        if( $entry->{'TMtypeid'} ) {
            $class_member{$entry->{'TMtypeid'}}=1;
        }
    }
    $sth->finish;
    $typelist=join ',', keys(%class_member);
}

#
# Get the headers referenced by 'header_depend' constants values
#

$select = "SELECT ACvalue, ACorder FROM Constant ";
$select.= "LEFT JOIN ArchConst ON Cid=ACcid ";
$select.= "LEFT JOIN HeaderGroup ON Cheadgroup=HGid ";
$select.= "WHERE HGheader=$Hid ";
$select.= "AND Ctype='header_depend' ";
# No check for withdrawn - we don't have any 'header_depend' constants withdrawn before 3.1
$select.= "AND ACappearedin > ''";
print $select,"\n" if $trace;
$sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
for(1..$sth->rows) {
    $entry = $sth->fetchrow_hashref;
    $header{$entry->{'ACvalue'}}=$entry->{'ACorder'};
}
$sth->finish;
$constlist=join '\',\'', keys(%const);

#
# Get LSB versions where this header is allowed in
#
if( $Hsrcerror ne "Yes" ) {
    $select = "SELECT Happearedin, Hwithdrawnin FROM Header WHERE Hid=$Hid ORDER BY Happearedin";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    $index=0;
    $appearedin='';
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        if( $sth->rows == 1 ) {
            # At the moment we don't have headers which appeared twice, but let's prevent possible collisions
            $header_appin = $entry->{'Happearedin'};
            $specdb::header_appin = $entry->{'Happearedin'};
        }
        $appearedin = $entry->{'Happearedin'};
        $appearedin =~ s/\.//;
        $withdrawnin = $entry->{'Hwithdrawnin'};
        $withdrawnin =~ s/\.//;

        if( $index > 0 ) {
            print "|| (__LSB_VERSION__ >= $appearedin ";
        }
        else {
            print "#if (__LSB_VERSION__ >= $appearedin ";
        }

        if( $withdrawnin ) {
            print "&& __LSB_VERSION__ < $withdrawnin";
        }
        print ")";
        $index++;
    }

    $sth->finish;
    print "\n";
}

#
# Set up multiple inclusion protection
#
print "#ifndef $protect\n";
print "#define $protect\n";
print "\n";

#
# Get the headers containing referenced types
#

if( $typelist ne "" ) {
    $select = "SELECT DISTINCT Hid FROM Type ";
    $select.= "LEFT JOIN HeaderGroup ON HGid=Theadgroup ";
    $select.= "LEFT JOIN Header ON Hid=HGheader ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "WHERE Tid IN ($typelist) ";
    $select.= "AND ( (ATappearedin <> '' ";
    $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
    $select.= "OR Tindirect='Yes' OR Tsrconly='Yes' OR Tconly='Yes' )";
    $select.= "AND Hid != $Hid ";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        $header{$entry->{'Hid'}}=1;
        }
    }
    $sth->finish;

#
# Output the headers this header needs to include
#
$hdrlist=join ',', keys(%header);
if( $hdrlist ne "" ) {
    $createTmp = "CREATE TEMPORARY TABLE tmp_HeadersDeps ";
    $createTmp.= "(KEY `Hid`(`Hid`,`ACorder`)) ";
    $createTmp.= "SELECT DISTINCT Hid, -1 AS ACorder FROM Header ";
    $createTmp.= "WHERE Hid IN ($hdrlist) ";
    $createTmp.= "AND Hid != $Hid ";
    $dbh->do($createTmp);

    foreach $dep_hid (keys %header) {
        if( $header{$dep_hid} > 1 ) {
            $dbh->do("UPDATE tmp_HeadersDeps SET ACorder=".$header{$dep_hid}." WHERE Hid=$dep_hid");
        }
    }

    $select = "SELECT Hname, Hid FROM tmp_HeadersDeps ";
    $select.= "JOIN Header USING(Hid) ";
    $select.= "ORDER BY ACorder, Hid ";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        if( $entry->{'Hname'} ) {
            my $header_name = $entry->{'Hname'};
            my $header_id = $entry->{'Hid'};

            #
            # determine if this header depends on
            # any types we are about to declare in this
            # header.
            #
            $header_typelist = get_typelist($entry->{'Hid'},1);
            if ($header_typelist) {
                $select = "SELECT DISTINCT Tid FROM Type ";
                $select.= "LEFT JOIN HeaderGroup ON HGid=Theadgroup ";
                $select.= "LEFT JOIN Header ON Hid=HGheader ";
                $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
                $select.= "WHERE Tid IN ($header_typelist) ";
                $select.= "AND ( (ATappearedin <> '' ";
                $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
                $select.= "OR Tsrconly='Yes' ) ";
                $select.= "AND Hid = $Hid ";
                print $select,"\n" if $trace;
                $sth2 = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
                $sth2->execute or die "Couldn't execute $select query: ".DBI->errstr;
                if ($sth2->rows) {
                    for(1..$sth2->rows) {
                        $header_entry = $sth2->fetchrow_hashref;
                        my $tid = $header_entry->{'Tid'};

                        $$header_name{$tid} = 1;
                        $$tid{$header_name} = 1;
                    }
                } else {
                    print "#include <".$header_name.">\n";
                }
                $sth2->finish;
            } else {
                print "#include <".$header_name.">\n";
            }

        }
    }
    $sth->finish;
}

if( $classlist ne "" ) {
    $select = "SELECT Tname,Tunmangled,Ttype FROM Type ";
    $select.= "WHERE Tid IN (\'$classlist\') ";
    print $select,"\n" if $trace;
    $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $sth->execute or die "Couldn't execute $select query: ".DBI->errstr;
    for(1..$sth->rows) {
        $entry = $sth->fetchrow_hashref;
        $name = $entry->{'Tunmangled'} ? $entry->{'Tunmangled'} : $entry->{'Tname'};
        $type = ( $entry->{'Ttype'} eq 'Class' ) ? "class" : "struct";
        print "$type $name;\n";
    }
    $sth->finish;
}

# if we have deprecated interfaces inside this header,
#     print LSB_DECL_DEPRECATED macro definition
$selectDepr = "SELECT Iid FROM Interface ";
$selectDepr.= "JOIN ArchInt ON AIint=Iid ";
$selectDepr.= "WHERE Iheader=$Hid ";
$selectDepr.= "AND AIdeprecatedsince IS NOT NULL ";
$selectDepr.= "AND AIappearedin > '' ";
$selectDepr.= "AND (AIwithdrawnin IS NULL OR AIwithdrawnin  > '3.0') ";
$selectDepr.= "LIMIT 1";
print $selectDepr,"\n" if $trace;
my $sthDepr = $dbh->prepare($selectDepr) or die "Couldn't prepare $selectDepr query: ".DBI->errstr;
$sthDepr->execute or die "Couldn't execute $selectDepr query: ".DBI->errstr;

if( $sthDepr->rows ) {
    print "\n";
    print "#if !defined(LSB_DECL_DEPRECATED)\n";
    print "#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && (__GNUC__ - 0 > 3 || (__GNUC__ - 0 == 3 && __GNUC_MINOR__ - 0 >= 2))\n";
    print "#define LSB_DECL_DEPRECATED __attribute__ ((__deprecated__))\n";
    print "#else\n";
    print "#define LSB_DECL_DEPRECATED\n";
    print "#endif\n";
    print "#endif    /* LSB_DECL_DEPRECATED */\n";
}

$sthDepr->finish;

if( !$classlist ) {
    print "\n#ifdef __cplusplus\n";
    print "extern \"C\" {\n";
    print "#endif\n\n";
}
else {
    print "// *INDENT-OFF*\n";
}

if( $Hsrcerror eq 'Yes' ) {
    print "#error \"This header not permitted by the LSB\"\n\n";
}

# dump AbiApi records
$select = "SELECT DISTINCT AAvalue, AAappearedin, AAwithdrawnin FROM AbiApi ";
$select.= "LEFT JOIN Interface ON (Iid=AAbinint OR Iid=AAsrcint) ";
$select.= "WHERE Iheader=$Hid ";
$select.= "AND AAappearedin <> '' ";
$select.= "ORDER BY AAappearedin, AAwithdrawnin ";
# $select.= "AND AAappearedin <= '$lsbversion' AND AAappearedin <> '' ";
# $select.= "AND (AAwithdrawnin IS NULL OR AAwithdrawnin > '$lsbversion') ";
print $select,"\n" if $trace;
my $sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;

my ($oldVersionAppeared, $oldVersionWithdrawn) = ($header_appin,"");

if( $sth->rows ) {
    print "\n";
}
for( 1..$sth->rows ) {
    my $aavalue = $sth->fetchrow_hashref;
    specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $aavalue->{'AAappearedin'}, $aavalue->{'AAwithdrawnin'} );
    $oldVersionAppeared = $aavalue->{'AAappearedin'};
    $oldVersionWithdrawn = $aavalue->{'AAwithdrawnin'};
    print $aavalue->{'AAvalue'}."\n";
}
if( $sth->rows ) {
    print "\n";
    if( $oldVersionWithdrawn ) {
        print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
    }

    if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
        print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
    }

}
$sth->finish;

#
# Get the info from the types in the $type hash
#
# Use the algorithm from admin/headers.php3

$select = "SELECT HGid,HGdescription,HGorder FROM HeaderGroup ";
$select.= "WHERE HGheader=$Hid ";
$select.= "ORDER BY HGorder";
print $select,"\n" if $trace;
$hgh = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$hgh->execute or die "Couldn't execute $select query: ".DBI->errstr;

for(1..$hgh->rows) {
    $entry = $hgh->fetchrow_hashref;
    $HGid=$entry->{'HGid'};
    $HGdesc=$entry->{'HGdescription'};
    $HGorder=$entry->{'HGorder'};
    # Make sure a blank line is present between every group
    print "\n";

    # Since it's a header, document it
    if( $HGorder != 0 && $HGdesc ne "" ) {
        print "/* ".$HGdesc."*/\n";
    }

    # Display the Constants
    #
    # Display the Constants excluding the generated header
    # dependency constants
    #
    $select = "SELECT * FROM Constant ";
    $select.= "LEFT JOIN ArchConst ON Cid=ACcid ";
    $select.= "LEFT JOIN Architecture ON Aid=ACaid ";
    $select.= "WHERE Cheadgroup=$HGid ";
    $select.= "AND ACappearedin > '' ";
    $select.= "AND (ACwithdrawnin IS NULL OR ACwithdrawnin > '3.0') ";
    $select.= "AND Ctype != 'header_depend'";
    $select.=" ORDER BY ACappearedin, ACwithdrawnin, ACorder, ACvalue, Cname, Aid";
    $ch = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $ch->execute or die "Couldn't execute $select query: ".DBI->errstr;
    print $ch->rows," rows\n" if $trace;

    $oldVersionAppeared = $header_appin;
    $oldVersionWithdrawn = '';

    for(1..$ch->rows) {
        $centry = $ch->fetchrow_hashref;

        specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $centry->{'ACappearedin'}, $centry->{'ACwithdrawnin'});
        $oldVersionWithdrawn = $centry->{'ACwithdrawnin'};
        $oldVersionAppeared = $centry->{'ACappearedin'};

        # If it's architecture sensitive, add the #if's to
        # make it work correctly.
        if( $centry->{'Aid'} && $centry->{'Aname'} ne "All" ) {
            print "#if ".$centry->{'Asymbol'}."\n";
            #print "/* ".$centry->{'Aname'}." */\n";
            specdb::displayconstant($centry);
            print "#endif\n";
        } else {
            specdb::displayconstant($centry);
        }
    }
    $ch->finish;

    if( $oldVersionWithdrawn ) {
        print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
    }
    if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
        print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
    }

    if( $ch->rows ) {
        print "\n\n";
    }

    %processedNames;

    # Display the Type (Typedef)
    $select = "SELECT * FROM Type ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "LEFT JOIN Architecture ON ATaid=Aid ";
    $select.= "WHERE Theadgroup=$HGid ";
    $select.= "AND ( (ATappearedin<>'' ";
    $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
    $select.= "OR Tsrconly = 'Yes' OR Tconly = 'Yes' ) ";
    $select.= "AND Ttype = 'Typedef' ";
    $select.= "AND Tclass = 0 ";
#   $select.= "AND Aid = $Aid ";
    # Potential problem, if we have inconsistencies among type and its base 'appearedin'
    $select.= "ORDER BY ATappearedin, ATwithdrawnin, Tid";
    print $select,"\n" if $trace;
    $th = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $th->execute or die "Couldn't execute $select query: ".DBI->errstr;
    print $th->rows," rows\n" if $trace;

    $oldVersionWithdrawn = "";
    $oldVersionAppeared = $header_appin;

    for(1..$th->rows) {
        $typeflag=0;
        $tentry = $th->fetchrow_hashref;

        if( $processed_typedefs{$tentry->{'Tid'}} ) {
            next;
        }

        if( $tentry->{'Aname'} ne "All" ) {
            if( specdb::isGenericTypePresent($tentry->{'Tid'}, "All") ) {
                next;
            }
        }

        specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $tentry->{'ATappearedin'}, $tentry->{'ATwithdrawnin'});
        $oldVersionWithdrawn = $tentry->{'ATwithdrawnin'};
        $oldVersionAppeared = $tentry->{'ATappearedin'};

        $TMaid = $tentry->{'Aid'} ? $tentry->{'Aid'} : $Aid;
        if( $tentry->{'Tconly'} eq "Yes" ) {
            print "#if !defined(__cplusplus)\n";
        }
        if( $tentry->{'Aid'} && $tentry->{'Aname'} ne "All" ) {
            print "#if ".$tentry->{'Asymbol'}."\n";
            print "/* ".$tentry->{'Aname'}." */\n";
            displaytype($tentry);
            print ";";
            if( $tentry->{'Tdescription'} ) {
                print "/* ".$tentry->{'Tdescription'}." */";
            }
            print "\n\n#endif\n";
        } else {
            displaytype($tentry);
            print ";";
            if( $tentry->{'Tdescription'} ) {
                print "/* ".$tentry->{'Tdescription'}." */";
            }
            print "\n\n";
        }
        if( $tentry->{'Tconly'} eq "Yes" ) {
            print "#endif\n";
        }

        # Display headers now that we've declared their
        # dependant types.
        foreach $header_name (keys %{$tentry->{'Tid'}}) {
            if (1 == scalar (keys %$header_name)) {
                print "#include <" . $header_name . ">\n";
            }
            delete $$header_name{$tentry->{'Tid'}};
        }
    }
    $th->finish;

    if( $oldVersionWithdrawn ) {
        print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
    }
    if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
        print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
    }

    $oldVersionWithdrawn = "";
    $oldVersionAppeared = $header_appin;

    # Display the Types (excluding Typedef)
#   if( !$param_typelist ) {
#       $param_typelist = "0";
#   }
    $select = "SELECT * FROM Type ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "LEFT JOIN Architecture ON ATaid=Aid ";
#   $select.= "LEFT JOIN Parameter ON Ptype=Tid ";
#   $select.= "LEFT JOIN Interface ON Iid=Pint ";
    $select.= "WHERE Theadgroup=$HGid ";
    $select.= "AND ( (ATappearedin<>'' ";
#   $select.= "AND ( ( (ATappearedin <= '$lsbversion' and ATappearedin<>'') ";
#   $select.= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin >'$lsbversion') ) ";
    $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
#   $select.= "OR ( Tid IN ($param_typelist) AND Ttype IN ('Struct','Union','Enum') AND Tname NOT LIKE 'anon%' )";
    $select.= "OR Tsrconly = 'Yes' OR Tconly = 'Yes' ) ";
    $select.= "AND Ttype != 'Typedef' ";
    $select.= "AND (Tclass=0 OR Ttype='Struct' OR Ttype='Class') ";
#   $select.= "AND Aid = $Aid ";
    $select.= "ORDER BY ATappearedin, ATwithdrawnin, Tid";
    print $select,"\n" if $trace;
    $th = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $th->execute or die "Couldn't execute $select query: ".DBI->errstr;
    print $th->rows," rows\n" if $trace;
    for(1..$th->rows) {
        $typeflag=0;
        $tentry = $th->fetchrow_hashref;

        if( $tentry->{'Aname'} ne "All" ) {
            # Check for included generic records
            if( specdb::isGenericTypePresent($tentry->{'Tid'}, "All" ) ) {
                next;
            }

            # Are we processing not-included not-generic type that came from param_typelist?
#           $select = "SELECT ATtid FROM ArchType LEFT JOIN Type ON ATtid=Tid ";
#           $select.= "WHERE Tid IN ($param_typelist) AND Ttype IN ('Struct','Union','Enum') AND ATaid=1 ";
#           $thArchSpec = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
#           $thArchSpec->execute or die "Couldn't execute $select query: ".DBI->errstr;
#           if( $thArchSpec->rows ) {
#               $thArchSpec->finish;
#               next;
#           }
#           $thArchSpec->finish;
        }

        if( $processedNames{($tentry->{'Tid'},$tentry->{'Aid'})} ) {
            next;
        }

        if( $processedNames{($tentry->{'Tid'},1)} ) {
            next;
        }

        $TMaid = $tentry->{'Aid'} ? $tentry->{'Aid'} : $Aid;

        specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $tentry->{'ATappearedin'}, $tentry->{'ATwithdrawnin'});
        $oldVersionWithdrawn = $tentry->{'ATwithdrawnin'};
        $oldVersionAppeared = $tentry->{'ATappearedin'};

        if( $tentry->{'Tconly'} eq "Yes" ) {
            print "#if !defined(__cplusplus)\n";
        }
        if( $tentry->{'Aid'} && $tentry->{'Aname'} ne "All" ) {
            print "#if ".$tentry->{'Asymbol'}."\n";
            print "/* ".$tentry->{'Aname'}." */\n";
            displaytype($tentry);
            print ";";
            if( $tentry->{'Tdescription'} ) {
                print "/* ".$tentry->{'Tdescription'}." */";
            }
            print "\n\n#endif\n";
        } else {
            displaytype($tentry);
            print ";";
            if( $tentry->{'Tdescription'} ) {
                print "/* ".$tentry->{'Tdescription'}." */";
            }
            print "\n\n";
        }
        if( $tentry->{'Tconly'} eq "Yes" ) {
            print "#endif\n";
        }

#       $processedNames{($tentry->{'Tid'},$Aid)} = 1;
        $processedNames{($tentry->{'Tid'},$tentry->{'Aid'})} = 1;
        $processedNamesOnly{$tentry->{'Tid'}} = 1;

        # Display headers now that we've declared their
        # dependant types.
        foreach $header_name (keys %{$tentry->{'Tid'}}) {
            if (1 == scalar (keys %$header_name)) {
                print "#include <" . $header_name . ">\n";
            }
            delete $$header_name{$tentry->{'Tid'}};
        }
    }
    $th->finish;

    if( $oldVersionWithdrawn ) {
        print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
    }
    if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
        print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
    }

    $oldVersionWithdrawn = "";
    $oldVersionAppeared = $header_appin;

    # Display the Types (Struct/Union)
    $select = "SELECT * FROM Type ";
    $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
    $select.= "LEFT JOIN Architecture ON ATaid=Aid ";
    $select.= "WHERE Theadgroup=$HGid ";
    $select.= "AND ( (ATappearedin<>'' ";
#   $select.= "AND ( ( (ATappearedin <= '$lsbversion' and ATappearedin<>'') ";
#   $select.= "AND (ATwithdrawnin IS NULL OR ATwithdrawnin >'$lsbversion') ) ";
    $select.= " AND (ATwithdrawnin IS NULL OR ATwithdrawnin >= '3.0' ) )";
    $select.= "OR Tsrconly = 'Yes' OR Tconly = 'Yes' ) ";
    $select.= "ORDER BY ATappearedin, ATwithdrawnin, Tid";
    print $select,"\n" if $trace;

    $th = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
    $th->execute or die "Couldn't execute $select query: ".DBI->errstr;
    print $th->rows," rows\n" if $trace;

    for(1..$th->rows) {
        $typeflag=1;
        $tentry = $th->fetchrow_hashref;
        if( $tentry->{'Aname'} ne "All" ) {
            if( specdb::isGenericTypePresent($tentry->{'Tid'}, "All") ) {
                next;
            }
        }

        if( $tentry->{'Ttype'} eq "Typedef" ) {
            $OldAid = $Aid;
            # Check if generic record for the basetype presents
            if( specdb::isGenericTypePresent($tentry->{'ATbasetype'}, "All") ) {
                $Aid=1;
            }
            else {
                $Aid = $tentry->{'Aid'};
            }

            # Maybe the necessary basetype has already been processed?
            #~ if( $processedNamesOnly{$tentry->{'ATbasetype'}} ) {
            if( $processedNames{($tentry->{'ATbasetype'},$Aid)} ) {
                next;
            }

            $processedNames{($tentry->{'ATbasetype'},$Aid)} = 1;
            $processedNamesOnly{$tentry->{'ATbasetype'}} = 1;
            #~ $processedNames{$tentry->{'ATbasetype'},1} = 1;

            $tselect = "SELECT * FROM Type LEFT JOIN HeaderGroup ON Theadgroup=HGid ";
            $tselect.= "WHERE Tid=".$tentry->{'ATbasetype'};
            $tselect.= " AND ( Ttype='Struct' OR Ttype='Union' ) AND HGheader=$Hid AND Tname NOT LIKE 'anon%' ";

            $tth = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
            $tth->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
            if($tth->rows) {
                specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $tentry->{'ATappearedin'}, $tentry->{'ATwithdrawnin'});
                $oldVersionWithdrawn = $tentry->{'ATwithdrawnin'};
                $oldVersionAppeared = $tentry->{'ATappearedin'};
                $ttentry = $tth->fetchrow_hashref;
                $TMaid = $tentry->{'Aid'} ? $tentry->{'Aid'} : $Aid;

                if( $ttentry->{'Tconly'} eq "Yes" ) {
                    print "#if !defined(__cplusplus)\n";
                }
                if( $tentry->{'Aid'} && $tentry->{'Aname'} ne "All" ) {
                    print "#if ".$tentry->{'Asymbol'}."\n";
                    print "/* ".$tentry->{'Aname'}." */\n";
                    displaytype($ttentry);
                    if ($semicolonNeeded) {
                        $semicolonNeeded = 0;
                        print ";";
                    }
                    if( $ttentry->{'Tdescription'} ) {
                        print "/* ".$ttentry->{'Tdescription'}." */";
                    }
                    print "\n\n#endif\n";
                } else {
                    displaytype($ttentry);
                    if ($semicolonNeeded) {
                        $semicolonNeeded = 0;
                        print ";";
                    }
                    if( $ttentry->{'Tdescription'} ) {
                        print "/* ".$ttentry->{'Tdescription'}." */";
                    }
                    print "\n\n";
                }
                if( $ttentry->{'Tconly'} eq "Yes" ) {
                    print "#endif\n";
                }
            }
            $tth->finish;
            $Aid = $OldAid;
        }

        # Display headers now that we've declared their
        # dependant types.
        foreach $header_name (keys %{$tentry->{'Tid'}}) {
            if (1 == scalar (keys %$header_name)) {
                print "#include <" . $header_name . ">\n";
            }
            delete $$header_name{$tentry->{'Tid'}};
        }
        $typeflag=0;
    }
    $th->finish;

    if( $oldVersionWithdrawn ) {
        print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
    }
    if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
        print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
    }

}
$hgh->finish;
#
# Dump out the function prototypes
#

$select = "SELECT * FROM Interface ";
$select.= "LEFT JOIN Type ON Ireturn=Tid ";
$select.= "LEFT JOIN ArchInt ON Iid=AIint ";
$select.= "LEFT JOIN ArchType ON ATtid=Tid AND ATaid=AIarch ";
$select.= "LEFT JOIN Architecture ON AIarch=Aid ";
$select.= "WHERE Iheader=$Hid ";
$select.= "AND Iid NOT IN ( SELECT AAsrcint FROM AbiApi ";
$select.= "  WHERE AAappearedin <= '$lsbversion' AND AAappearedin <> '' ";
$select.= "  AND (AAwithdrawnin IS NULL OR AAwithdrawnin > '$lsbversion') ";
$select.= ") ";
$select.= "AND (Isrcbin='SrcOnly' ";
$select.= " OR ( (Isrcbin='Both' OR Iid IN ( ";
$select.= "  SELECT AAbinint FROM AbiApi ";
$select.= "  WHERE AAappearedin <= '$lsbversion' AND AAappearedin <> '' ";
$select.= "  AND (AAwithdrawnin IS NULL OR AAwithdrawnin > '$lsbversion') ";
$select.= ")) AND ";
$select.= "AIappearedin > '' AND (AIwithdrawnin IS NULL OR AIwithdrawnin > '3.0') ) ";
$select.= ") ";
# Hope check for libstdcxx is temporary and will be eliminated when we get more
# graceful c++ headers generators
$select.= "AND (Iclass=0 OR Ilibrary='libstdcxx') ";
$select.= "ORDER BY AIappearedin, AIwithdrawnin, Iname ";
print $select,"\n" if $trace;
$sth = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
$sth->execute or die "Couldn't execute $select query: ".DBI->errstr;

if( $sth->rows ) {
    print "\n/* Function prototypes */\n\n";
}

$oldVersionAppeared = $header_appin;
$oldVersionWithdrawn = '';

for(1..$sth->rows) {
    $entry = $sth->fetchrow_hashref;

    if( $entry->{'Aid'} != 1 ) {
        $selectGeneric = "SELECT Iid FROM Interface ";
        $selectGeneric.= "LEFT JOIN ArchInt ON Iid=AIint ";
        $selectGeneric.= "WHERE AIarch=1 AND AIint='$entry->{'AIint'}'";
        $selectGeneric.= "AND Iid NOT IN ( ";
        $selectGeneric.= " SELECT AAsrcint FROM AbiApi ";
        $selectGeneric.= " WHERE AAappearedin > '' ";
        $selectGeneric.= " AND (AAwithdrawnin IS NULL OR AAwithdrawnin > '3.0') ";
        $selectGeneric.= ") AND (Isrcbin='SrcOnly' ";
        $selectGeneric.= "OR ( (Isrcbin='Both' OR Iid IN ( ";
        $selectGeneric.= " SELECT AAbinint FROM AbiApi ";
        $selectGeneric.= " WHERE AAappearedin > '' ";
        $selectGeneric.= " AND (AAwithdrawnin IS NULL OR AAwithdrawnin > '3.0') ";
        $selectGeneric.= ")) AND ";
        $selectGeneric.= "(AIappearedin > '') ";
        $selectGeneric.= "AND (AIwithdrawnin IS NULL OR AIwithdrawnin >'3.0') ) ) ";
        $selectGeneric.= "LIMIT 1";
        $sthGeneric = $dbh->prepare($selectGeneric) or die "Couldn't prepare $selectGeneric query: ".DBI->errstr;
        $sthGeneric->execute or die "Couldn't execute $selectGeneric query: ".DBI->errstr;
        if( $sthGeneric->rows ) {
            $sthGeneric->finish;
            next;
        }
        $sthGeneric->finish;
    }

    if( $entry->{'Isrcbin'} ne 'SrcOnly' ) {
        specdb::printLsbVersionBounds( $oldVersionAppeared, $oldVersionWithdrawn, $entry->{'AIappearedin'}, $entry->{'AIwithdrawnin'});
        $oldVersionAppeared = $entry->{'AIappearedin'};
        $oldVersionWithdrawn = $entry->{'AIwithdrawnin'};
    }
    else {
        if( $oldVersionWithdrawn ) {
            print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
            $oldVersionWithdrawn = '';
        }

        if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
            print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
            $oldVersionAppeared = '';
        }
    }

    # Check if we have a macro with the same name; undef, if any
    $macroName = $entry->{'Iname'};
    $macroName =~ s/_/\\_/g;
    $checkMacro = "SELECT Cid FROM Constant ";
    $checkMacro.= "JOIN ArchConst ON ACcid=Cid ";
    $checkMacro.= "WHERE Cname LIKE '$macroName(%' ";
    $checkMacro.= "AND ACappearedin > '' ";
    $checkMacro.= "AND (ACwithdrawnin IS NULL OR ACwithdrawnin > '3.0') ";
    $checkMacro.= "LIMIT 1";
    $cth = $dbh->prepare($checkMacro) or die "Couldn't prepare $checkMacro query".DBI->errstr;
    $cth->execute or die "Couldn't execute $checkMacro query: ".DBI->errstr;
    if( $cth->rows ) {
        print "#undef ".$entry->{'Iname'}."\n";
    }
    $cth->finish;

    if( $entry->{'Itype'} eq "Function" ) {
        $TMaid = $tentry->{'Aid'} ? $tentry->{'Aid'} : $Aid;

        if( $entry->{'Aid'} && $entry->{'Aname'} ne "All" ) {
            print "#if ".$entry->{'Asymbol'}."\n";
            print "/* ".$entry->{'Aname'}." */\n";
        }
        printf "extern ";

        $funcPtrName = '';
        if( $entry->{'Ttype'} eq 'FuncPtr' ) {
            $funcPtrName = $entry->{'Iname'};
#            print STDERR "Skipping a global function pointer!!\n";
#            next;
        }
        $Iid = $entry->{'Iid'};
        $Ttype = $entry->{'Ttype'};
        $Iname = $entry->{'Iname'};
        $Tid = $entry->{'Ireturn'};

        displaytyperef($entry);
        if ($Ttype eq "FuncPtr") {
            print "(\n";
        } else {
            print " $Iname(";
        }
        $funcPtrName='';

        $select = "SELECT Tid,Tname,Ttype,ATbasetype,Parsize FROM Parameter,Type ";
        $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
        $select.= "WHERE Pint=".$Iid." AND Ptype=Tid ";
        $select.= "GROUP BY Ppos ORDER BY Ppos";
        print $select,"\n" if $trace;
        $sth2 = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
        $sth2->execute or die "Couldn't execute $select query: ".DBI->errstr;
        if( $sth2->rows != 0 ) {
            $typeflag=0;
            $entry2=$sth2->fetchrow_hashref;
            displaytyperef($entry2);
            if( $entry2->{'Ttype'} eq "Array" ) {
                print "[";
                if( $entry2->{'Parsize'} != 0 ) {
                    print $entry2->{'Parsize'};
                }
                print "]";
            }
            for(2..$sth2->rows) {
                $entry2 = $sth2->fetchrow_hashref;
                print ", ";
                displaytyperef($entry2);
                if( $entry2->{'Ttype'} eq "Array" ) {
                    print "[";
                    if( $entry2->{'Parsize'} != 0 ) {
                        print $entry2->{'Parsize'};
                    }
                    print "]";
                }
            }
        } else {
            print "void";
        }
        print ")";

        if( $Ttype eq "FuncPtr" ) {
            print ")(";

            $tmselect = "SELECT * FROM TypeMember WHERE TMmemberof=$Tid AND TMaid IN (1,$TMaid) ";
            $tmselect.= "ORDER BY TMposition";
            $tmh = $dbh->prepare($tmselect) or die "Couldn't prepare $tmselect query: ".DBI->errstr;
            $tmh->execute or die "Couldn't execute $tmselect query: ".DBI->errstr;
            if($tmh->rows == 0) {
                print "void";
            }
            for(1..$tmh->rows) {
                $tmentry = $tmh->fetchrow_hashref;
                $TMtypeid=$tmentry->{'TMtypeid'};
                $tselect="SELECT * FROM Type ";
                $tselect.="LEFT JOIN ArchType ON ATtid=Tid ";
                $tselect.="WHERE Tid=$TMtypeid ";
                $tselect.="AND ATaid IN($Aid,1) GROUP BY Tid ";
                $th = $dbh->prepare($tselect) or die "Couldn't prepare $tselect query: ".DBI->errstr;
                $th->execute or die "Couldn't execute $tselect query: ".DBI->errstr;
                $entry = $th->fetchrow_hashref;
                $th->finish;
                $nameonly=1;
                displaytype($entry);
        #       print $tmentry->{'TMname'};
                #~ if($entry->{'Ttype'} eq 'Array') {
                    #~ if( $tmentry->{'TMarray'} ) {
                        #~ print "[".$tmentry->{'TMarray'}."]";
                    #~ }else{
                        #~ print "[".$entry->{'ATsize'}."]";
                    #~ }
                #~ }
                if( $_ != $tmh->rows ) {
                    print ",";
                }
                #~ $nameonly=0;
            }

            print ")\n";
            $tmh->finish;
        }

        if( $entry->{'AIdeprecatedsince'} and $entry->{'AIdeprecatedsince'} ne 'Unknown' ) {
            print " LSB_DECL_DEPRECATED";
        }
        print ";\n";
        $sth2->finish;
        if( $entry->{'Aid'} && $entry->{'Aname'} ne "All" ) {
            print "#endif\n";
        }
    }
    if( $entry->{'Itype'} eq "Data" ) {
        printf "extern ";
        displaytyperef($entry);
        printf " %s",$entry->{'Iname'};
        if( $entry->{'Ttype'} eq "Array" ) {
            print "[";
            if( $entry->{'ATsize'} != 0 ) {
                print $entry->{'ATsize'};
                }
            print "]";
        }
        if( $entry->{'Ttype'} eq "Const" || $entry->{'Ttype'} eq "Volatile") {
            if( $entry->{'ATbasetype'} != '' ) {
                $basetype = $entry->{'ATbasetype'};
            }
            else {
                $selectBase = "SELECT ATbasetype FROM ArchType ";
                $selectBase.= "WHERE ATtid=".$entry->{'Tid'}." ";
                $selectBase.= "GROUP BY ATbasetype";
                $sthBase = $dbh->prepare($selectBase) or die "Couldn't prepare $selectBase query: ".DBI->errstr;
                $sthBase->execute or die "Couldn't execute $selectBase query: ".DBI->errstr;
                if($sthBase->rows > 1) {
                    die "Couldn't determine basetype for type ".$entry->{'Tid'}." on $Aid architecture";
                }

                $base = $sthBase->fetchrow_hashref;
                $sthBase->finish;
                $basetype = $base->{'ATbasetype'};
            }

            $select = "SELECT * FROM Type ";
            $select.= "LEFT JOIN ArchType ON ATtid=Tid ";
            $select.= "LEFT JOIN Architecture ON Aid=ATaid ";
            $select.= "WHERE Tid=".$basetype." ";
            $select.= "AND ATaid=$Aid";
            print $select,"\n" if $trace;
            my $stm = $dbh->prepare($select) or die "Couldn't prepare $select query: ".DBI->errstr;
            $stm->execute or die "Couldn't execute $select query: ".DBI->errstr;
            my $btype = $stm->fetchrow_hashref;
            $stm->finish;
            if( $btype->{'Ttype'} eq "Array" ) {
                print "[";
                if( $btype->{'ATsize'} != 0 ) {
                    print $btype->{'ATsize'};
                }
                print "]";
            }
        }

        printf " ;\n";
    }
    if( $entry->{'Itype'} eq "Alias" ) {
        printf "extern ";
        displaytyperef($entry);
        printf " %s",$entry->{'Iname'};
        if( $entry->{'Ttype'} eq "Array" ) {
            print "[";
            if( $entry->{'ATsize'} != 0 ) {
                print $entry->{'ATsize'};
                }
            print "]";
        }
        printf " ;\n";
    }
    if( $entry->{'Itype'} eq "Common" ) {
        printf "extern ";
        displaytyperef($entry);
        printf " %s",$entry->{'Iname'};
        if( $entry->{'Ttype'} eq "Array" ) {
            print "[";
            if( $entry->{'ATsize'} != 0 ) {
                print $entry->{'ATsize'};
                }
            print "]";
        }
        printf " ;\n";
    }
}
$sth->finish;

if( $oldVersionWithdrawn ) {
    print "#endif /* __LSB_VERSION__ < $oldVersionWithdrawn */\n\n";
}

if( $oldVersionAppeared and $oldVersionAppeared gt $header_appin ) {
    print "#endif /* __LSB_VERSION__ >= $oldVersionAppeared */\n\n";
}

if( !$classlist ) {
    print "#ifdef __cplusplus\n";
    print "}\n";
    print "#endif\n";
}
else {
    print "// *INDENT-ON*\n";
}
print "#endif /* protection */\n";

if( $Hsrcerror ne "Yes" ) {
    print "#endif /* LSB version */\n";
}

$dbh->disconnect;

